<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title></title>
    <url>%2F2017%2F10%2F29%2Faaa%2F</url>
    <content type="text"><![CDATA[asasasas ads]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2017%2F10%2F29%2Fa%2F</url>
    <content type="text"><![CDATA[asasas]]></content>
  </entry>
  <entry>
    <title><![CDATA[最棒的WebApp项目]]></title>
    <url>%2F2017%2F10%2F26%2Fwebapp%2F</url>
    <content type="text"><![CDATA[中医智库 我自己做的，没有对比就没有伤害 不过说心里话，这个网站是我见过的最棒的WebApp项目。一个网站最重要的是什么？很明显当然是用户体验。常常被挂在嘴边的做的如何可能只有自己知道。无论你用到了什么技术，都必须要明白一件事技术是为产品服务的。好了，扯远了，谈谈该项目吧。 项目架构技术论证common区开发用一切皆模块表达一点也不为过。比如说： 项目收获项目总结]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端实用代码合集]]></title>
    <url>%2F2017%2F10%2F20%2F%E5%89%8D%E7%AB%AF%E4%BB%A3%E7%A0%81%E5%90%88%E9%9B%86%2F</url>
    <content type="text"><![CDATA[无论代码写的好与坏，都在心里默念3遍： 写的就是坨屎； 写的就是坨屎； 写的就是坨屎； 这样你会有源源不断的动力完善自己的代码，反正我就是这样。同事A君：真是个欠货。 JavaScriptTab切换123456789101112131415161718192021222324252627282930313233343536373839//eg1var tabs=document.getElementById(&quot;tab&quot;).getElementsByTagName(&quot;li&quot;);var divs=document.getElementById(&quot;tabCon&quot;).getElementsByTagName(&quot;div&quot;); for(var i=0;i&lt;tabs.length;i++)&#123; tabs[i].onclick=function()&#123;change(this);&#125;&#125; function change(obj)&#123; for(var i=0;i&lt;tabs.length;i++)&#123; if(tabs[i]==obj)&#123; tabs[i].className=&quot;fli&quot;; divs[i].className=&quot;fdiv&quot;; &#125;else&#123; tabs[i].className=&quot;&quot;; divs[i].className=&quot;&quot;; &#125; &#125;&#125;//这是我最认可的实现方式，你也可以通过传参实现，但那造成结构与功能的不分离。//eg2$(&apos;.box li&apos;).mouseover(function()&#123; var $this = $(this); var $num = $this.index(); $(&apos;.box section&apos;).css(&apos;display&apos;,&apos;none&apos;); $(&apos;.box section&apos;).eq($num).css(&apos;display&apos;,&apos;block&apos;);&#125;);//eg3$(&apos;.tab&apos;).css(&apos;display&apos;,&apos;none&apos;).eq(0).css(&apos;display&apos;,&apos;block&apos;);$(&apos;li&apos;).click(function ()&#123; $(this).addClass(&apos;active&apos;).siblings().removeClass(&apos;active&apos;); for (var i=0;i&lt;3;i++) &#123; $(&apos;#content div&apos;).eq(i).css(&apos;display&apos;,&apos;none&apos;) &#125; $(&apos;#content div&apos;).eq($(this).index()).css(&apos;display&apos;,&apos;block&apos;)&#125;); 手风琴效果123456789101112131415161718192021//eg1for(var j=0;j&lt;4;j++)&#123; show[j].onclick=function ()&#123; var ul=this.getElementsByTagName(&apos;ul&apos;)[0]; var h2=this.getElementsByTagName(&apos;h2&apos;)[0]; arr(); h2.className=&quot;bg&quot;; ul.style.height=&quot;170px&quot;; &#125;&#125;function arr()&#123; for(var i=0;i&lt;show.length;i++)&#123; show[i].getElementsByTagName(&apos;h2&apos;)[0].className=&apos;&apos;; show[i].getElementsByTagName(&apos;ul&apos;)[0].style.height=&apos;0&apos;; &#125;&#125;//eg2$(this).parent().siblings().find(&apos;ul&apos;).removeClass(&apos;on&apos;);$(this).parent().find(&apos;ul&apos;).toggleClass(&apos;on&apos;);//你也可以通过动态添加类来实现。 轮播图1234567891011121314151617//无缝轮播$(&quot;.oraign&quot;).clone().appendTo(&apos;.list&apos;);if(!$(&apos;.list&apos;).is(&quot;:animated&quot;) )&#123; if($(&apos;.list&apos;).css(&apos;left&apos;)==&apos;-3294px&apos;)&#123; $(&apos;.list&apos;).css(&#123;left:&apos;-0px&apos;&#125;,500) &#125; $(&apos;.list&apos;).stop(true,true).animate(&#123;left:&apos;-=&apos;+$width&#125;,500)&#125;//这里要注意的一点是结构一定要正确，它应该是这样：&lt;div&gt; &lt;div&gt; &lt;ul&gt; &lt;li&gt;&lt;/li&gt; ... &lt;/ul&gt; &lt;/div&gt;&lt;/div&gt; 至于其他嘛，无论是通过fadeIn、fadeOut实现还是通过定位实现，还是使用其他控件实现都无可厚非，完成功能就OK。但自己还是喜欢通过自己写的代码实现，这是件很有成就感的事情。 使用FileReader实现前端图片预览12345678910111213&lt;input type=&quot;file&quot;&gt;&lt;br&gt;&lt;img src=&quot;&quot; height=&quot;200&quot; alt=&quot;Image preview area...&quot; title=&quot;preview-img&quot;&gt;var fileInput = document.querySelector(&apos;input[type=file]&apos;);var previewImg = document.querySelector(&apos;img&apos;);fileInput.addEventListener(&apos;change&apos;, function () &#123; var file = this.files[0]; var reader = new FileReader(); reader.addEventListener(&apos;load&apos;, function () &#123; previewImg.src = reader.result; &#125;, false); reader.readAsDataURL(file);&#125;, false); 取到页面中所有的checkbox123456789var doc = document, domList = doc.getElementsByTagName(&apos;input&apos;), checkBoxList = [], len = domList.length;while (len--) &#123; if (domList[len].type === &apos;checkbox&apos;) &#123; checkBoxList.push(domList[len]); &#125;&#125; 判断某变量是否为数组数据类型12345if (typeof Array.isArray === &quot;undefined&quot;) &#123; Array.isArray = function (arg) &#123; return Object.prototype.toString.call(arg) === &quot;[object Array]&quot; &#125;;&#125; 对象拷贝与赋值123456789var obj = &#123; name: &apos;xiaoming&apos;, age: 23&#125;;var newObj = obj;newObj.name = &apos;xiaohua&apos;;console.log(obj.name);//xiaohuaconsole.log(newObj.name);//xiaohua//newObj对象获得的只是一个内存地址，而不是真正的拷贝。 深拷贝123456789var obj = &#123; name: &apos;xiaoming&apos;, age: 23&#125;;var newObj = Object.create(obj);newObj.name = &apos;xiaohua&apos;;console.log(obj.name);//xiaomingconsole.log(newObj.name);//xiaohua//Object.create()方法可以创建一个具有指定原型对象和属性的新对象。 闭包实现封装123456789101112131415var person = function () &#123; var name = &quot;Default&quot;; return &#123; getName: function () &#123; return name; &#125;, setName: function (newName) &#123; name = newName; &#125; &#125;&#125;();console.log(person.name);//undefinedconsole.log(person.getName());//Defaultperson.setName(&quot;GoodMan&quot;);console.log(person.getName());//GoodMan 写到这里又让我想到了之前遇到的一个问题：获取li的索引 1234567891011121314151617181920212223242526var liArr = document.querySelectorAll(&apos;li&apos;);var len = liArr.length;for (var i = 0; i &lt; len; i++) &#123; btns[i].onclick = function (index) &#123; // 闭包可以将变量驻留在内存中，防止被垃圾回收机制回收 return function () &#123; console.log(index); &#125; &#125;(i);&#125;//也可以这样window.onload=function()&#123; var ul=document.getElementById(&apos;test&apos;); var ul_lis=ul.getElementsByTagName(&apos;li&apos;); for (var i = 0;i &lt; ul_lis.length; i++) &#123; ul_lis[i].index = i; ul_lis[i].onclick=function()&#123; var j=this.index+1; alert(j); &#125; &#125;&#125;;//还可以这样$(this).index(); 条条大路通罗马，选择最高效的，遵循最佳实践。 jQuery设置等高的列1234567891011121314151617181920212223&lt;div class=&quot;equalHeight&quot; style=&quot;border: 1px solid&quot;&gt; &lt;p&gt;First Line&lt;/p&gt; &lt;p&gt;Second Line&lt;/p&gt; &lt;p&gt;Third Line&lt;/p&gt;&lt;/div&gt;&lt;div class=&quot;equalHeight&quot; style=&quot;border: 1px solid&quot;&gt; &lt;p&gt;Column Two&lt;/p&gt;&lt;/div&gt;$(function () &#123; equalHeight(&quot;.equalHeight&quot;);&#125;);var maxHeight = 0;function equalHeight(col) &#123; col = $(col); col.each(function () &#123; if ($(this).height() &gt; maxHeight) &#123; maxHeight = $(this).height() &#125; &#125;); col.height(maxHeight);&#125; 参考文章]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顿悟【二】]]></title>
    <url>%2F2017%2F10%2F13%2F%E9%A1%BF%E6%82%9F2%2F</url>
    <content type="text"><![CDATA[今天看到一篇文章，很有感触，原文在这里，自己看 家庭矛盾，大都来源于自作自受 这里我只说自己的婚姻观，两点： 做不到孝，免谈； 彼此支持、理解对方的选择，做不到，免谈； 不管对方有多优秀，以上是我的底线。可能，有时会因为对方很漂亮 很温柔等原因，但这如果不满足以上2点，只适合谈恋爱，不适合做灵魂伴侣。 WOW，这位小伙子很XXX啊，没办法，一代好母亲，3代好家庭，这件事，我必须慎重考虑。正如Spenser说的:结婚前要擦亮双眼，结婚后就是睁一只眼，闭一只眼。这句话包含3个意思： 第一，结婚是人生最重要的一笔投资，你所有的时间、财富、精力、快乐，都和这笔投资息息相关。所以结婚前擦亮双眼，要谨慎，用你的智慧去判断这个人值不值得信任。 第二，睁一只眼，就是要看到爱情和婚姻里的可能性风险，最好用制度和协议的方式来规范和约束两者的关系，比如管好各自的边界和权益，比如定下家里的财政大权谁掌管，当出现隐形的第三者风险的时候，如何巧妙的处理，等等。 第三，闭一只眼的意思，就是要选择主动信任对方。大家都知道，在一段关系里，如果某一方真想要出轨的话，是根本不可能通过监视的手段来避免。也就是说，技术手段不是万无一失的。 我始终坚信一点，最好的关系是价值对等。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[三个M引发的思考]]></title>
    <url>%2F2017%2F10%2F05%2F3M%2F</url>
    <content type="text"><![CDATA[这里要说到一款强大的移动端编辑工具HBuilder，自带Mui框架，真是无敌，敲了3个M移动端的基本模型出来了，什么轮播图、Tab切换、折叠面板应有尽有。这让我想到了自己的前端开发之路。从更开始的小红本，到后来的DW，再到HBilder，Webstorm，现在又在尝试sublime。编辑器的升级又何尝不是自己成长之路呢。 选择一个工具的原因很多，但最主要的原因应是可以提高开发效率，而不是盲目追新。一项技术被人们推崇是因为解决了某种问题而不是因为使用了多么牛逼的技术。我始终坚信一点技术是为产品服务的。 这样的例子太多太多。比如在做某一个项目的时候用到了XX技术，由于之前写过一个Demo,直接引用文件就OK了。总而言之，一句话，遵循最佳实践。 啊啊啊，写不下去了，没灵感了。那就写一个Demo吧！我就只想静静的敲会代码。 灵感聚集地： 传送门 优秀个站： 个人网站 个人网站2 两个天蝎座的老前辈，哎，我也是天蝎男可技术咋就这么垃圾呢？前方路途遥远，少年仍需努力。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[One hundred]]></title>
    <url>%2F2017%2F10%2F05%2F%E5%8D%9A%E5%AE%A2100%2F</url>
    <content type="text"><![CDATA[写给第100篇博客，有时候我在想，100篇带给我什么，技术的长进？总结能力？还是其他什么。在这中间，有过凑字数的想法，但后来还是放弃了。即使这样，还是有些写的不是太理想，这就需要日后不断改善。自己做的东西，一定要喜欢，不然就没什么意义了。 时刻提醒自己，少即是多。从自己关注的公众号就可体现出来。从之前三四十个，到现在的10多个，我给自己设的上线就是绝不超过20个。这已经很多了，就像网上说的，看100篇文章不如自己写一篇。它只能拓展自己的眼界，但这是必不可少的。一天30分钟足够。 今天很巧，又发现一个自己喜欢的公号。讲的很纯粹，值得深思。 片段1你遇到的男人贪图的是色，付出的是荷尔蒙，与爱情啊什么的根本没有什么关系。而你，却是动了心动了情，你付出的是爱。 男人要的是一时欢虞，女人要的是一世相守，不在一个频道上，当然一言不合就分开了。这种感情，开始的时候，大多带着耀眼的光环，让人看到的都是美好。但最终，带给人的，一定是锥心刺骨的疼痛。梦醒时分会非常痛，非常痛。 片段2这一生，谁是我们最重要的人？我认为，除却父母子女不能。当然还有夫妻，还有兄弟姊妹，但我觉得都比不上父母子女的骨肉亲情。 一个人，无论多么自私冷漠，在身为父母后，也会变得柔软而温暖。如果说让他们变成孩子脚下的水泥路，可以带孩子走向更好更大的世界，他们一定会躬身伏地，无怨无悔。 我们小的时候，父母是大树，给我们一地荫凉为我们遮风挡雨。父母在的地方，就是我们的家。而等父母老去的时候，我们就成了父母的保护伞，你在哪，哪就是他们的家。 片段3一个人真爱你的时候，他会站在你的角度考虑问题，他宁可伤害自己，也不愿伤害自己爱的人。是的。每一个人在成年后，都在寻找真爱，寻找自己的另一半。而这个找的过程中，会遇到烦恼，遇到忧愁，也会遇到伤害。可是，一个真正值得爱的人并不是很容易找到，更多的是穷极一生也遇不到。 片段4爱从眼角出发，奔向鬓角，这貌似很短的距离，却需要一生的跋涉才能抵达。所有的情，都是从耳鬓厮磨中走出来，最终变成心疼和牵挂。 是啊，世间所有的爱，都指向团聚，唯有父母的爱，指向别离…… 孩子，我让你去飞翔，不是让你和别人比什么，而是因为，我希望你将来拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在自己觉得有意义的时候，你才能快乐，才能有勇气去攀登更高的山峰，去看更美的风景。 但人生路上，难免会遇到风雨，妈妈会为你准备一个爱的港湾，让你，随时可以停靠。当你遇到挫折与困难，不必惊慌，我一直都在家里等你回来，我会像你小时候那样，牵着你的手，带你走过风风雨雨，人生路上，我会努力多伴你一程，再一程。 宝贝，趁你还在我身边，还未曾长大，让我好好疼你，爱你吧。终有一天，你也会拥有蓬勃的力量，张开翅膀，去属于你的天空飞翔。 愿你，眼中有光芒，活成，你想要的模样。 片段5真正的修养，不仅是宏观的道德，更有那些细节的温度。其实，幸福，根本不是惊天动地，轰轰烈烈，而是那些细微的，让我们置身其中，感受不到存在甚至感到无聊的东西，真的等到失去它时，才发现，那一切是多么多么的美好。 幸福，不是拿到了世界上最好的东西，而是，珍惜了生命中的所有。 终有一天，你会发现，你寻找的幸福，根本不是什么浓烈的罗曼蒂克，而是一个个平淡如水的日子，是一个来了再也没走的人。 片段6多年前看过一个电视剧，里面有一段剧情印象很深。 美丽的女主爱上了一位已婚男人，那个男的也喜欢她，二人只是暗生情愫，并无挑明。一次，女主喝多了，让男人送她回家。二人独处一室，女主在男人怀里哭得一塌糊涂。男人的脸上是百般克制的表情，看得出，他是在拼命压抑住自己的欲望。后来，女主睡着了，他为她盖好被子悄悄走了。那一刻，我看到了真爱。 围城里的人想出来，外面的人想进去。生活本来就是这样。有人做过一个测试，在一个80万人的城市，遇见灵魂伴侣的几率是0.53，甚至不到1人。 尊重，是发自内心把对方当回事，给人体面的同时，也流露出自己高贵的人格，和良好的教养。有时，越是微不足道的细节，越会自然流露。 北京是我的福地 人生在世不过数十年，要明白一点，赚钱是为家人提供更好的生活。看过太多为赚钱与亲人分离，这是很不应该的。“别在秀你加班到深夜了，除了证明你可替代性强以外再也不能证明什么”，努力提升自己，让自己变得不可替代或者说难以替代才是我们每个人都应考虑的。 你要你的孩子接受什么样的教育，当北漂吗？那给予欠发达地区的孩子提供实现梦想的机会。北京，承载了无数人的梦想，也破碎了无数人的梦想。总之，我要为我的家人提供我理想的生活，不管自己多么艰辛，一定要为家人提供优质的生活。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一生只做一件事]]></title>
    <url>%2F2017%2F10%2F01%2F%E4%B8%80%E7%94%9F%E5%8F%AA%E5%81%9A%E4%B8%80%E4%BB%B6%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[一生只做一件事，平衡钱、权、欲之间的关系。本质而言，还是一个字欲，因为钱、权归根结底都是为欲做铺垫的。每当自己心浮气躁的时候，总忍不住去西藏看看，那里是个圣地，能让人静下心来。曾看过一句话，浮躁是来源于内心的不安全感，在这个物欲横飞的年代，能做到心静着实不易。 静下心来，找一本好书，亦或是去图书馆，找一个安静的角落，用一本书打发自己的一天。生活，本应该慢下来，赚钱是为了更好的生活。但试问：有钱就一定能过上好生活吗？曾看过Spenser一片文章，“别傻了，你根本过不上有钱有闲的生活“。有钱没闲，有闲没钱。恐怕是多数人的宿命吧！ 人活在这世上，都是为了最高级的自我实现，当还在温饱阶段的时候，赚钱就是最基础的实现途径。 当过了财富增长点的时候，成就感就来自于自己被这个世界，被别人需要的程度了。 工作带给你的，根本不是金钱的收入那么简单，是人生终极价值实现的路径。另一方面，一个人真正的优雅，来自于压力下的优雅。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[最牛逼的 HTML 和 CSS 代码]]></title>
    <url>%2F2017%2F09%2F28%2Fi043%2F</url>
    <content type="text"><![CDATA[在前端开发领域，最难的其实是HTML，其次是CSS，最后才是JS。当然这句话是不正确的，然而我们真需要老说那么正确的话吗？正确的话很多时候还不如不正确的话那么对人有用。比对错更重要的是对场景、环境的理解、把控。 “最牛逼”只是修饰语，表示强调，就如我说“最难”的是HTML一样。看到这种微博时，别急着去反驳有更牛逼的HTML，或去思考JS比HTML难呀。 HTML1234&lt;div class=&quot;box&quot;&gt; &lt;div class=&quot;hd&quot;&gt;&lt;/div&gt; &lt;div class=&quot;bd&quot;&gt;&lt;/div&gt;&lt;/div&gt; 为何只有 hd 和 bd？ft 呢？ 为何用 div 而不是 section / header 等？ 为何 hd 里的标签没做约定？ 这段代码，是为了满足什么需求？ 对于复杂需求，这个代码如何变化？ 简单和复杂之间如何权衡？（很多程序员倾向于把事情搞复杂） 为何不是 mod / mod-hd / mod-bd ？ 在什么场景下这段代码不适用？（比如组合命名和长命名之争） 这东西跟性能没关系。 这东西跟可维护性关系很大。 究竟什么是结构与样式的分离？ 衡量一个好的HTML代码的标准是什么？ 结构化设计是什么？ 部分如何构建出整体？砖瓦是怎么变成大厦的？ 关注度分离是个啥东西？ 什么是抽象？抽象的价值究竟是啥？ 什么是创新？什么是超越？ CSS1234567891011.content &#123; width: 980px; margin-left: auto; margin-right auto;&#125;//但大多数情况下，我们会这样写.content &#123; width: 980px; margin: 0 auto;&#125; 上面的代码看上去更多了，但有没有想过这样的问题呢： margin: 0 auto 中的 0 绝大部分情况下是冗余的，页面上早就有 reset.css 或 normalize.css 重置过 margin: 0 auto 不纯粹，你要的是“水平居中”，却顺便把 top / bottom 给重置了 不纯粹会导致顺序和优先级的依赖，比如有另一处要给 margin-top/bottom 赋值时，就必须要提高优先级 CSS中一个最重要的原则：最小影响原则 与HTML代码一样，对CSS代码来说，很重要的两个衡量标准也是稳定和灵活。 JavaScript1&lt;a href=&quot;javascript:alert(&apos;清除成功&apos;)&quot;&gt;清除缓存&lt;/a&gt; 这是我见过最牛逼的JS代码，没有之一。对JS代码，我认为有3个段位： 实现业务需求 实现业务需求+代码健壮 实现代码需求+代码健壮+可复用 参见 玉伯]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[善良比聪明重要]]></title>
    <url>%2F2017%2F09%2F25%2F%E5%96%84%E8%89%AF%E6%AF%94%E8%81%AA%E6%98%8E%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[2010 年，亚马逊 CEO 杰夫·贝佐斯（Jeff Bezos）在母校普林斯顿大学的毕业典礼上，勉励年轻人，善用自己的天赋，做出对的选择。因为，「人生到头来，我们的选择，决定了我们是什么样的人。」 以下是 Bezos 演讲内容： As a kid, I spent my summers with my grandparents on their ranch in Texas. I helped fix windmills, vaccinate cattle, and do other chores. We also watched soap operas every afternoon, especially “Days of our Lives.” My grandparents belonged to a Caravan Club, a group of Airstream trailer owners who travel together around the U.S. and Canada. And every few summers, we’d join the caravan. We’d hitch up the Airstream trailer to my grandfather’s car, and off we’d go, in a line with 300 other Airstream adventurers. I loved and worshipped my grandparents and I really looked forward to these trips. On one particular trip, I was about 10 years old. I was rolling around in the big bench seat in the back of the car. My grandfather was driving. And my grandmother had the passenger seat. She smoked throughout these trips, and I hated the smell. 孩提时代，我总是在德州祖父母的农场中度过夏天。我帮忙修理风车，为牛接种疫苗，也做其他杂活。每天下午，我们也看肥皂剧，特别是《光辉岁月》。祖父母参加了一个房车俱乐部，一群人驾驶 Airstream 房车，结伴游历美国和加拿大。每隔几个夏天，我们会加入一次旅程。把房车挂在祖父的小汽车后面，融入 300 余名 Airstream 探险者的浩荡队伍中，就这样出发。我爱祖父母，心怀敬仰，很期盼这些旅程。在我大约 10 岁时，有一次很特殊的旅程。那次我胡乱坐在后座上，祖父开着车，祖母坐在他旁边。整个旅程祖母都吸着烟，我讨厌烟味。 At that age, I’d take any excuse to make estimates and do minor arithmetic. I’d calculate our gas mileage – figure out useless statistics on things like grocery spending. I’d been hearing an ad campaign about smoking. I can’t remember the details, but basically the ad said, every puff of a cigarette takes some number of minutes off of your life: I think it might have been two minutes per puff. At any rate, I decided to do the math for my grandmother. I estimated the number of cigarettes per days, estimated the number of puffs per cigarette and so on. When I was satisfied that I’d come up with a reasonable number, I poked my head into the front of the car, tapped my grandmother on the shoulder, and proudly proclaimed, “At two minutes per puff, you’ve taken nine years off your life!” I have a vivid memory of what happened, and it was not what I expected. I expected to be applauded for my cleverness and arithmetic skills. “Jeff, you’re so smart. You had to have made some tricky estimates, figure out the number of minutes in a year and do some division.” That’s not what happened. Instead, my grandmother burst into tears. I sat in the backseat and did not know what to do. While my grandmother sat crying, my grandfather, who had been driving in silence, pulled over onto the shoulder of the highway. He got out of the car and came around and opened my door and waited for me to follow. Was I in trouble? My grandfather was a highly intelligent, quiet man. He had never said a harsh word to me, and maybe this was to be the first time? Or maybe he would ask that I get back in the car and apologize to my grandmother. I had no experience in this realm with my grandparents and no way to gauge what the consequences might be. We stopped beside the trailer. My grandfather looked at me, and after a bit of silence, he gently and calmly said, “Jeff, one day you’ll understand that it’s harder to be kind than clever.” 当年，我总是想尽办法去做估测或小算术。我会计算油耗还有杂货花销等鸡毛蒜皮的小事。我听过一个与吸烟相关的广告，但记不清细节了。广告大意是，每吸一口香烟会减少几分钟寿命，好像是两分钟。管它几分钟呢，我决定为祖母做个算术。我估测了祖母每天吸几支香烟，每支香烟吸几口等等，然后心满意足地得出了一个合理的数字。接着，我把头探入汽车前排，拍了拍祖母的肩膀，骄傲地宣称：「如果每吸一口烟少活两分钟的话，你的寿命已经少了九年！」我清晰地记得接下来发生的事，是我意料之外的。凭借聪明的大脑和算术技巧，我期待赢来夸赞：「杰夫，你真聪明。你应该做一些更需要技巧的算术，比如一年有多少分钟，以及做些除法。」我的期待并没有发生。相反，祖母突然哭泣起来，我坐在后座茫然无措。祖父一直在默默开车，听到祖母的哭声，把车停在高速路边。祖父走下车来，打开车门，等我跟他下车。我惹麻烦了吗？祖父是一个智慧而安静的人。他从来没有对我说过严厉的话，难道这会是第一次？还是他会让我回到车上给祖母道歉？我以前从未遇到过这种状况，无从知晓会有什么后果发生。我们在房车旁停下来，祖父注视着我，沉默片刻，然后轻轻地、平静地说： 「杰夫，有一天你会明白，善良比聪明更难。」 What I want to talk to you about today is the difference between gifts and choices. Cleverness is a gift, kindness is a choice. Gifts are easy – they’re given after all. Choices can be hard. You can seduce yourself with your gifts if you’re not careful, and if you do, it’ll probably be to the detriment of your choices. This is a group with many gifts. I’m sure one of your gifts is the gift of a smart and capable brain. I’m confident that’s the case because admission is competitive and if there weren’t some signs that you’re clever, the dean of admission wouldn’t have let you in. 今天我想对你们说的是，天赋和选择的不同。 聪明是一种天赋，而善良是一种选择。 天赋得来容易 —— 毕竟与生俱来。而选择颇为不易。一不小心，你可能会被天赋所诱惑，而这可能会损害到你的选择。 在座各位都拥有众多天赋。我确信你们的天赋之一就是拥有精明能干的头脑。之所以如此确信，是因为入学竞争如此激烈，如果你们不聪明，便不会有资格进入这所学校。 Your smarts will come in handy because you will travel in a land of marvels. We humans — plodding as we are – will astonish ourselves. We’ll invent ways to generate clean energy and a lot of it. Atom by atom, we’ll assemble tiny machines that will enter cell walls and make repairs. This month comes the extraordinary but also inevitable news that we’ve synthesized life. In the coming years, we’ll not only synthesize it, but we’ll engineer it to specifications. I believe you’ll even see us understand the human brain. Jules Verne, Mark Twain, Galileo, Newton – all the curious from the ages would have wanted to be alive most of all right now. As a civilization, we will have so many gifts, just as you as individuals have so many individual gifts as you sit before me. How will you use these gifts? And will you take pride in your gifts or pride in your choices? 你们将在一片充满奇迹的世界上前行，聪明才智必能派上用场。我们人类，尽管跬步前行，却终将令自己大吃一惊。我们能够想方设法制造清洁能源等等，也能够一个原子一个原子地组装微型机械，使之穿过细胞壁，去修复细胞。这个月，有一个非常激动人心却又不足为奇的消息 —— 人类终于合成了生命。在未来几年，我们不仅会合成生命，还能将之工程规范化。我相信你们甚至会看到人类大脑被彻底理解。儒勒·凡尔纳、马克·吐温、伽利略、牛顿 —— 所有那些充满好奇之心的人都希望能够活在现在。作为文明人，我们拥有如此多的天赋，就像是坐在我面前的你们，每一个生命个体都拥有众多独特的天赋。如何运用这些天赋？为自己的天赋感到骄傲，还是会为自己的选择感到骄傲？ I got the idea to start Amazon 16 years ago. I came across the fact that Web usage was growing at 2,300 percent per year. I’d never seen or heard of anything that grew that fast, and the idea of building an online bookstore with millions of titles – something that simply couldn’t exist in the physical world – was very exciting to me. I had just turned 30 years old, and I’d been married for a year. I told my wife MacKenzie that I wanted to quit my job and go do this crazy thing that probably wouldn’t work since most startups don’t, and I wasn’t sure what would happen after that. MacKenzie (also a Princeton grad and sitting here in the second row) told me I should go for it. As a young boy, I’d been a garage inventor. I’d invented an automatic gate closer out of cement-filled tires, a solar cooker that didn’t work very well out of an umbrella and tinfoil, baking-pan alarms to entrap my siblings. I’d always wanted to be an inventor, and she wanted me to follow my passion. 16 年前，我萌生了创办亚马逊的想法。当年，互联网使用量以每年 2300% 的速度增长，我从未看到或听说过任何东西增长如此快速。有个想法令我异常兴奋 —— 创建涵盖几百万种书籍的网上书店，这东西在物理世界根本无法存在。那时我刚满 30 岁，结婚才一年。我告诉妻子 MacKenzie 想辞去工作，然后去做这件疯狂的事，很可能会失败，因为大部分创业公司都如此，而且我不确定之后会发生什么。MacKenzie （也是普林斯顿毕业生，就坐在下面第二排）告诉我，我应该放手一搏。少年时期，我是一名车库发明家。我曾用水泥填充的轮胎制作自动关门器，用雨伞和锡箔制作太阳能炒锅（虽然不太好用），我还用煎锅做了一个警报器来吓唬邻居。我一直想做一个发明家，MacKenzie 支持我追随内心的热情。 I was working at a financial firm in New York City with a bunch of very smart people, and I had a brilliant boss that I much admired. I went to my boss and told him I wanted to start a company selling books on the Internet. He took me on a long walk in Central Park, listened carefully to me, and finally said, “That sounds like a really good idea, but it would be an even better idea for someone who didn’t already have a good job.” That logic made some sense to me, and he convinced me to think about it for 48 hours before making a final decision. Seen in that light, it really was a difficult choice, but ultimately, I decided I had to give it a shot. I didn’t think I’d regret trying and failing. And I suspected I would always be haunted by a decision to not try at all. After much consideration, I took the less safe path to follow my passion, and I’m proud of that choice. 我当时在纽约一家金融公司工作，同事是一群非常聪明的人，老板也很有智慧，我很敬佩他。我告诉老板我想开办一家公司，在网上卖书。老板带我在中央公园漫步良久，认真听我讲完，最后说：「听起来真是一个很好的主意。然而，对那些目前没有谋到一份好工作的人来说，这个主意会更好。」这一逻辑对我而言颇有道理，老板说服我做出最终决定之前再考虑 48 小时。那样想来，这个决定确实很艰难，但是最终，我决定拼一次。 我认为自己不会为尝试过后的失败而遗憾，倒是有所决定但完全不付诸行动会一直煎熬着我。 深思熟虑后，我选择了那条不安全的道路，去追随内心的热情。我为自己的决定感到骄傲。 Tomorrow, in a very real sense, your life – the life you author from scratch on your own – begins.How will you use your gifts? What choices will you make?Will inertia be your guide, or will you follow your passions?Will you follow dogma, or will you be original?Will you choose a life of ease, or a life of service and adventure?Will you wilt under criticism, or will you follow your convictions?Will you bluff it out when you’re wrong, or will you apologize?Will you guard your heart against rejection, or will you act when you fall in love?Will you play it safe, or will you be a little bit swashbuckling? When it’s tough, will you give up, or will you be relentless?Will you be a cynic, or will you be a builder?Will you be clever at the expense of others, or will you be kind? 明天，非常现实地说，从零塑造自己人生的时代，即将开启。你会如何运用自己的天赋？又会做出怎样的抉择？你会随波逐流，还是追随内心的热情？你会顺从于教条，还是保持初心？你会选择安逸的生活，还是奉献与冒险的人生？你会屈于批评，还是会坚守信念？你会掩饰错误，还是会坦诚道歉？你会因害怕拒绝而掩饰真心，还是会在深爱中勇往直前？你想要波澜不惊，还是想搏击风浪？你会在严峻的现实之下选择放弃，还是会义无反顾前行？你要做愤世嫉俗者，还是踏实建设者？你要不计一切地展示聪明，还是选择善良？ I will hazard a prediction. When you are 80 years old, and in a quiet moment of reflection narrating for only yourself the most personal version of your life story, the telling that will be most compact and meaningful will be the series of choices you have made. In the end, we are our choices. Build yourself a great story. Thank you and good luck! 我要做一个预测：在大家 80 岁追忆往昔的时刻，一个人静静对内心诉说人生故事时，其中最为充实、最有意义的那段故事，会是大家做出的一系列选择。最后， 是选择塑造了我们，为自己塑造一个伟大的故事吧。 谢谢，祝福好运！ （完）转自: https://github.com/lifesinger/blog/issues/227]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS数组去重]]></title>
    <url>%2F2017%2F09%2F20%2Fi042%2F</url>
    <content type="text"><![CDATA[ES6版本ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。这样我们可以理解为，将数组转化为集合，再由集合转化为数组。1[...new Set(arr)] 最简洁12345//利用Array.filtervar arr = [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;, &quot;1&quot;, &quot;3&quot;];arr = arr.filter( function( item, index, inputArray ) &#123; return inputArray.indexOf(item) == index; &#125;);//Output: [&quot;1&quot;, &quot;2&quot;, &quot;3&quot;] 这个写法相对简洁，但效率并不怎么高，不适合太长的数组。 改进版123456function uniq(a) &#123; var seen = &#123;&#125;; return arr.filter(function(item) &#123; return seen.hasOwnProperty(item) ? false : (seen[item] = true); &#125;);&#125; 这个写法比上一个更有效率,但是有两个缺陷，对于Number和String来说，该算法不能区分，比如： 1uniq([1,&quot;1&quot;,2,&quot;2&quot;])//返回[1, 2] 同理，对于对象来说也不能区分，所有对象都被认为相等。所以使用时要明确使用场景。 1uniq([&#123;foo:1&#125;,&#123;foo:2&#125;])//返回[&#123;foo:1&#125;] 最终版12345678910function uniq(a) &#123; var prims = &#123;&quot;boolean&quot;:&#123;&#125;, &quot;number&quot;:&#123;&#125;, &quot;string&quot;:&#123;&#125;&#125;, objs = []; return a.filter(function(item) &#123; var type = typeof item; if(type in prims) return prims[type].hasOwnProperty(item) ? false : (prims[type][item] = true); else return objs.indexOf(item) &gt;= 0 ? false : objs.push(item); &#125;);&#125; 配合babel，嗯，无敌。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[顿悟]]></title>
    <url>%2F2017%2F09%2F16%2F%E9%A1%BF%E6%82%9F%2F</url>
    <content type="text"><![CDATA[今天，无意间在朋友圈看到这样一段话，印象比较深刻。 当你放下面子赚钱的时候，说明你已经懂事了。当你用钱赚回面子的时候，说明你已经成功了。当你用面子可以赚钱的时候，说明你已经是人物了。当你还停留在那里喝酒、吹牛，啥也不懂还装懂，只爱所谓的面子的时候，说明你这辈子也就这样了。 自己顶多也就处于懂事阶段，有时候，放下所谓的面子，想想如何赚钱，为家人提供优质生活，面子，又算什么。自己又不是什么大佬，面子意味着形象，不能轻易掉身价，那就，想想如何多赚几毛钱吧！真的，面子，现在对我来说，什么也不算，没有什么实质价值。 犹记得Spenser说的，“赚钱就是自我打脸的过程，打脸，打的是过去冲动的、甚至是有些任性的己”。丢到那些所谓的面子吧，没意义。只有小孩子才谈梦想，成年人都会学着向金钱低头的。我们还没有精力，担负起对世界的责任。拼命赚钱，挑起对家庭的责任，就已经让多少人苟延残喘了。 最后，引用下Spenser说的： 我们不能信誓旦旦的说：“我要让这个世界变得更好”。而是低声下气、小心询问：“世界啊，怎样做你才能让我过的好一点？”尽管，有钱不一定过的好。但是，没钱，一定很不好。所以，在通向财富自由之路上，打脸，消肿，再打脸，再消肿——终于变成了一个真正的胖子。 即便残忍，但也没那么悲凉，不是没有好处。与其说，我们不得不去追逐曾经忽略的、接受从前厌恶的人和事，倒不如换一个角度： 是你在跌跌撞撞中，学会谦逊，改掉自大。懂得保持开放，接纳各种可能性，用美好的眼光，去透视这个世界。长大成人后，你不一定非要变成那个从前厌恶的自己。When life gives you lemons, make lemonade。你以为老天给你的，是苦涩的柠檬，实际上，只是你厨艺不精。 当你有能力做出柠檬汁时，就明白所谓苦难，才是最珍贵的财富。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[生活本应如此]]></title>
    <url>%2F2017%2F09%2F06%2F10.1%2F</url>
    <content type="text"><![CDATA[4天，很快，转眼间就过去了，今天休息的时候，遇到一件事，让自己搞不明白。一个看似小伙子的中年人来应聘保安，为什么这样说呢，年龄37，应聘一份月薪不到3000块的工作，在工作面前毫无选择的余地，只能被人割韭菜。请原谅我这样说，实在想不到更好的表达了，可能每个人都有各自向往生活的权利，但那个年龄段里，怎么也应该以W计吧。 曾看过一篇文，年入10W靠努力，百万靠能力，千万靠。。。扯远了，我对自己的要求是，从不设上限，但一定要有底线，若干年后，可能5年，也可能3年，自己有实力做到当老板要求自己加无意义的班时，敢说不～即使要加班，也得自己愿意。我自己非常讨厌感动自我的加班，wow，你这小伙子好有个性啊，没办法啊，我就只想与家人在一块，无论是出游还是陪家人，赚钱不就是为了这个吗？其实，钱在我眼里，就是纸，无非就是随着社会发展到一定程度繁衍出的一种媒介罢了。总之，感概良多，祝自己好运。 还有一个不得不说的，遇到一位很有气质的菇凉，聊了大概2 3个小时吧。作为一名北京农大的大学生，来这里做志愿者，自己也又有幸认识这位漂亮的女孩还是蛮开心的。可能一辈子也就见这一次，也有可能还会遇到，那样的话真是天大的缘分，感谢生命中的每次相遇，珍惜生命中的每次相遇。她是我见过最有气质的。不吹，在我眼中，漂亮的女孩不一定有气质，有可能是妆出来的，但有气质的女孩一定很漂亮。而她属于后者。我不相信那些所谓的一见钟情，但是她，我释然了。说不喜欢是假的，漂亮的女孩不乏追求者，尤其像她这样的。我唯一能做的就是不时的看看她的朋友圈，她过得很好，恩，这就够了。正所谓老话说的“百年修得同船渡，千年修得共枕眠”，我不奢望能得到她的青睐，但还是想以朋友名义关注着她。张菇凉，你真的很迷人。 最后说说两位中年志愿者吧！说到了子女的教育，大致意思是，在孩子高中毕业后，直接学一门技术，早些参加工作，积累些社会经验，大学生真没什么，在这个年代，大学生一抓一大把，对211 985还另当别论，但其他也就是其他了。不管何时，我始终认为一个优秀的人最应具备就是解决问题能力，不管什么学习能力，沟通能力还是其他什么能力，都是为了更好的解决问题。这是我始终坚信的并时刻践行。 一次4天经历，撇了老半天，那以后还不得出本书啊啊啊。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6总结]]></title>
    <url>%2F2017%2F08%2F26%2Fi040%2F</url>
    <content type="text"><![CDATA[ES6新特性 let关键字，用于声明只在块级作用域起作用的变量。 const，用于声明一个常量。 结构赋值，一种新的变量赋值方式，常用于交换变量值，提取函数返回值，设置默认值。 symbol数据类型，用于定义一个独一无二的值。 proxy代理，用于编写函数，来拦截目标对象的操作。 for…of遍历，可遍历具有iterator 接口的数据结构。 Set结构，用于存储不重复成员值的的集合。 Map结构，键名可以是任何类型的键值对集合。 Promise对象，更合理、规范地处理异步操作。 Class类定义类和更简便地实现类的继承。 关于Set结构1234let s=new Set( );s.add([1]);s.add([1]);console.log(s.size); //2 Set结构不会存储相同的值，但这个例子中，2个数组[1]并不是同一个值，存储在不同的内存中，因此并不是相同的值。 关于Map结构12345let map = new Map( );map.set([1],&quot;ES6&quot;);let con = map.get([1]);console.log(con); //undefined 2个数组并不是同一个数组，只不过数值都是1。可通过以下代码实现。 123456let map = new Map( );let arr = [1];map.set(arr,&quot;ES6&quot;);let con = map.get(arr);console.log(con); //ES6 全新数据类型symbol 终于，JavaScript有了第七种数据类型：Symbol，创建一个独一无二的值；它用于对象的属性，设计初衷是为了避免对象属性冲突的问题。要获取对象symbol类型的属性，要用Object.getOwnPropertySymbols( )；还提供了Symbol.for( )和Symbol.keyFor( )方法用于搜索对应的symbol值。 当symbol的值作为对象的属性名时，无法用点运算符获取对应的值，如： 12345678let name = Symbol();let person = &#123; [name]:&quot;张三&quot;&#125;;console.log(person[name]);//结果：张三console.log(person.name);//结果：undefined 当symbol类型的值作为对象的属性名时，要用【】，不能用点运算符，如： 123456let name = Symbol();let person = &#123;&#125;;person.name = &quot;张三&quot;;person[name]; //结果：undefinedperson[&apos;name&apos;]; //结果：张三person.name; //结果：张三 symbol.for()函数 作用：根据参数名，去全局环境中搜索是否有以该参数为名的symbol值，有就返回它，没有就以该参数名来创建一个新的symbol值。 123let n1 = Symbol.for(&apos;name&apos;);let n2 = Symbol.for(&apos;name&apos;);console.log(n1 === n2); //true Symbol.keyFor( )函数 作用：返回一个以被登记在全局环境中的symbol值的key，没有就返回undefined。总而言之一句话：symbol值是被Symbol.for( )创建的，不是被Symbol( )创建的。 关于symbol，还得再唠叨2句，不然记不住 Symbol()创建symbol值不会被登记在全局环境中供Symbol.for()和Symbol.keyFor()搜索； Symbol.keyFor()函数在全局环境中找不到对应的symbol，就回返回undefined。 ES6的 Iterator 遍历器 Iterator遍历器的原理： 当可遍历对象被for…of遍历的时候，Symbol.iterator就会被调用，返回一个iterator对象。其中还有一个很重要的方法：next( )； for…of原理 先调用可遍历对象的Symbol.iterator方法，得到一个iterator遍历器对象，然后就在遍历器上不断调用next( )方法，直到done的值为true的时候，表示遍历结束。 Iterator遍历器的价值 由于数据结构都实现了Iterator遍历器接口，供for…of遍历，使得for…of能够遍历不同的数据结构。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《Web全栈工程师的自我修养》]]></title>
    <url>%2F2017%2F08%2F24%2FWeb%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E8%87%AA%E6%88%91%E4%BF%AE%E5%85%BB%2F</url>
    <content type="text"><![CDATA[一个人牛逼不是因为他做了什么，而是他可以选择不做什么。同样的，一个合格的全栈工程师应该从能力和思维方式两方面来判定。 什么是全栈工程师 全栈工程师是指，一个能处理数据库、服务器、系统工程和客户端的所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web栈，或者原生应用程序栈。 加班加班的一个原则就是不加班做白天遗留下的工作。赚钱有两种方式，一种是降低成本【节流】，另一种是赚更多的钱【开源】。同样的，导致加班的原因也不外乎效率低，任务紧。效率可以自己不断摸索，达到最佳实践。任务可以团队合作，达到1+1&gt;&gt;2效果。还有一种说法是团伙，这时候就体现出一个有魄力的领导者的魅力了。 对加班的看法 讨厌任何形式的为加班而加班的加班，这是在感动自我，没任何意义。若项目紧，或因自我原因导致项目进展缓慢，加班到深夜我绝不会说什么，这是我的责任。但千万别为了加班而加班。正如网上说的“加班就像借钱，救急不救穷”。 X理论与Y理论 一种假设“人性本恶”，即所有的员工都讨厌工作，只要没有监督，就一定会偷懒怠工，绝大多数人没有雄心壮志，怕担责任，宁可被领导骂。多数人必须用强制办法乃至惩罚、威胁，使他们为达到组织目标而努力。这叫做X理论。 另一种假设“人性本善”，即所有的员工都热爱工作，只要给他们创造舒适的环境、合理的授权和适当的激励，他们就会发挥很高的生产力，能力的限制和惩罚不是让人为组织目标而努力的唯一办法。这叫做Y理论。 用户体验 stay hungry,stay foolish. 真正聪明的人，不会显露自己，反而从表面看好像还很笨拙。 关注用户体验，关注用户体验，关注用户体验。自己做得东西，自己一定要喜欢，自己都不喜欢还指望别人会喜欢？ 性格 不要为了迎合主流社会，而伪装成一个外向、热情、合群的人。内向并不是一个贬义词，它是中立的，懂得扬长避短就好。所谓自我提升就是接纳接纳自我，而不是贬低自己的性格特征。 内向性格的竞争力 内向性格的人更容易沉下心来读书、思考，做一些安静的事。 内向性格的人跟人交往是对精力的消耗，但这并不代表情商低。情商低是无法察觉自己和他人情绪的波动，也许很外向，但很让人讨厌。内向但情商高的人，能够感知周围人的情绪，并敏锐的捕获到周围发生的事情。 其实，能灵活自如地适应各种社交场合的内向者往往有很强的自我意识、社会意识、自我管理和关系管理能力，加上自我学习能力，是很强的一种性格特征。 性格来自自己的基因，保持纯粹就好。 自我意识，是指您能够精准地觉察自己的情绪波动。 社会意识，是指您能感知周围人的情绪，并敏锐捕捉到周围发生的事情。 自我管理，是指您能根据自我情绪的感知，灵活积极地调控自身行为。 关系管理，是指您感知到周遭的“情绪场”之后，能够掌控自我情绪并把握他人情绪值，来让双方进行更好的互动。 金字塔原则 任何事情都可得出一个中心论点，而此中心论点可由3至7个论据支持，这些一级论据本身也可以是论点，被二级的3至7个论据支持，如此延伸，状如金字塔。 使用金字塔方法的前提是，只能有一个中心目标。比如，先赚它120W。 聊聊管理引用下《卓有成效的管理者》中的思维核心的习惯。 有效的管理者知道他们的时间用在什么地方。 有效的管理者重视对外界的贡献。 有效的管理者善于利用长处，包括自己的长处、上司的长处、同事的长处和下属的长处。 有效的管理者集中精力于少数重要的领域，在这少数重要的领域中，如果能有优秀的绩效就可以产生卓越的成果。 有效的管理者必须善于做有效的决策。 科学家与工程师 过去的工程师普遍不在意设计。有意或者无意，他们忽视设计的重要性。 “我发现程序员大致可以分为科学家和工程师两类，科学家关注技术是否优越，而工程师关注产品是否完美。和科学家类型的程序员合作项目往往是件痛苦的事情，他们太过关注自己手中的锤子是否先进，却不在意自己敲进去的钉子是否平整光滑不扎屁股，更不要说这颗钉子是不是跟其他钉子对齐了。那些“资深”程序员更是如此，那个年代很多用户体验的技术不成熟，能做出一个能用的东西已经不易，更不要说做出一个性能还算不错的产品了。抱着这个想法走到今天，大多数应该被淘汰的程序员却反而坐到了更高的位置，开始拿这种过时的想法熏陶小弟。”（来自陈鑫的回答） 简直不能再同意。 本书目录索引，有惊喜哦！如何成为全栈工程师不断打怪升级，不断打怪升级，不断打怪升级。 从学生到工程师其实就是打怪升级的历程。 野生程序员这种标签不属于我。 工程师事业指南用心做好每件事，把自己当成公司思考，嗯，说大了。 全栈工程师眼中的HTTP必须学习，不要问我为什么。 高性能网站的关键：缓存这不，HTML5增加了离线缓存。 大前端前端水很深，入坑需谨慎。 向移动端转型比如，自己做的WebApp。 持续集成团队与团伙，遵循最佳实践。 理解编程语言那就慢慢理解吧！ 全栈游乐场玩的玩的就无法自拔了。 高效工程师高效才是王道。 facebook的品牌设计故事要相信品牌的力量。 全栈思维“一专多长”，努力成为T型人才。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[战狼I VS 战狼II]]></title>
    <url>%2F2017%2F08%2F22%2F%E6%88%98%E7%8B%BC%2F</url>
    <content type="text"><![CDATA[战狼I VS 战狼II坦率的讲，我更欣赏I,也看了好几遍了，真是百看不厌呢！今天，看了下新出的战狼II,坦率的讲，有点失望，难道是自己的期望过高了吗？我想，没有吧！II给我的感觉就是一切都在主角的掌控中，无论是开篇遇到海盗，一个人救了整个船上的人。还是之后与恐怖份子的斗争中，都以开了挂的存在呢？这种超能，恐怕也只有电影，电视中存在吧。II给我最震撼的地方在于结尾时的： 中华人民共和过公民：当你在海外遭遇危险，不要放弃！请记住，在你身后，有一个强大的祖国！ 说到这里，就不得不提下今年的八一阅兵，当3架歼-20出现在画面中，让我深深的感觉到国家的强大。愿祖国繁荣昌盛。同时，也祝自己以后在技术路上有所成就！ 以后这里就是我的电影家了。。。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>Movies</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我待驾照如初恋]]></title>
    <url>%2F2017%2F08%2F08%2F%E9%A9%BE%E7%85%A7%2F</url>
    <content type="text"><![CDATA[在经过一年多的折腾后，可算把驾照考下了。 2016-06-25考科一 2016-10-03考科二 2017-07-28考科三 2017-08-08考科四 这时间跨度可真不短啊，不过也都是一次性通过，少了好多麻烦！ 时间回到科目一：首先，早上6、7点钟出发赶往考点，之后排队准备进行考试，好不容易该我考试了，心里窃喜，不过考的时候我傻眼了，TMD我前十道题错了3道，这就着实吓到了我，我仔细检查，跟我在驾考宝典上一样啊。这可怎么办，在来2个X我就拜拜了。这时，我跑到窗口向工作人员询问，才得知，那是系统故障，只要电脑不给你提示错误那答案就是正确的。我深吸一口气，平静一下我的小心脏。回到原位继续答题。一路也还顺畅。考试结果还不错98！之后签字离开这个是非之地。请原谅我这样表达，那个小插曲，着实让我不爽！ 时间回到科目二：啊！寒假了。考试走起想到这里，拿起手机138XXX打过去：“喂，教练，给咱约科二吧”。之后就等消息练车，恩，感觉还不错。准备战斗。说到这里又让我想起了科目一，哎！满满的心酸啊！适应场地得晚上适应啊！黑灯瞎火的，倒库就挂了，我硬是把前一个车库的线当成出库线，半坡还好，S那可就惨了，一路压着冲过去，侧方直接就跳过了。就这样，60大洋没了。第二天，早起再次熟悉考场，绕了一圈出来准备待考。哎~轮到我了，11车，上车踩离合挂一档，起步。恩，进入倒库项目，深户一口气，平复下小心脏。这是却发现安全带没系，这要是点了开始，可不直接说拜拜。系好安全帯，开始考试。倒库合格，下一项，半坡熄火，距离不够-20。啊，危险了，就这样就如S弯，压线，请将车开会起点从新考试。恩，这一步，已经在我心中预演了好几遍了。从新进入考试，经过前面教训，我过关斩将，到了S弯，看着后视镜，额，线呢，完了完了，再看，哦来了，就这样扭出S弯，进行下一项，考试合格。请将车开会起点。好开森，100有木有，签字走人。 时间回到科目三：科三考试还算顺畅，提前练了3个课时，果断100通过。可能是前面被虐的有经验了吧！其实，我挺幸运的，路线熟悉，车也不错，关键系统在我考的时候没出故障。我亲眼看见与我同车的2人系统故障说拜拜。 时间回到科目四：5:30闹钟响起，起床赶往考场，恩。很好，不像可以那样电脑有问题，是新电脑。很快考完了，98！和可以一样，有木有。准备签字，这是却把我吓了一跳，没拍到正脸，取消成绩从考，我的天，要不要这样。就在我发愣时，监考员说，签字。可能是勉强可以吧！哎~心累。至此，考试结束。 特此写篇博客记录下我的驾考之旅！]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈CSS学习中的瓶颈]]></title>
    <url>%2F2017%2F08%2F05%2Fcss%2F</url>
    <content type="text"><![CDATA[都知道CSS入门容易，但当技术达到一定程度时，便会发觉技术停滞不前了。这时候，我们已经进入瓶颈期了。这时候就需要我们静下心来，深入学习。下面，看几个问题： 有时候，如果我们CSS的基础足够得扎实与强大，我们会自热而然进入到B阶段，但这种完全经验积累的进阶学习需要很长的时间周期。 如果没有一定的CSS基础以及经验做支撑，我们是无法进入B阶段的。 深度才是你的核心竞争力。深入的细节掌握，深入的机制理解等，这些都是要下苦功才能掌握的，这是你有别于其他千千万万自认为会写页面的CSSer们的地方！ 它的增长曲线应是这样的 dl, dt, dd三个标签浏览器默认margin值多少？是否有标签默认文字粗体？ line-height:150%和line-height:1.5的区别是？ float为何会让外部容器高度塌陷？这是bug？ 一丝的文章 vertical-align的表现为何在IE7, IE8, IE9下表现不尽相同？其中的渲染机制是？ 张鑫旭 答案第一题 dl有默认margin值，没有padding值。在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px;在IE6.0,7.0中：margin:19px 0px; dd标签有默认margin-left：40px； 需要注意的是ul、ol具有默认padding。ol,ul标签：有默认margin-（top,bottom且相同）值，有默认padding-left值在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中：margin:12px 0px;在IE6.0,7.0中：margin:19px 0px;默认padding-left值：在Chrome,Firefox,Safari,Opera,Maxthon,IE8.0中都是padding-left：40px;在IE6.0,7.0中没有默认padding值，因为ol,ul标签的边框不包含序号。 第二题有单位时，子元素继承了父元素计算得出的行距；无单位时继承了系数，子元素会分别计算各自行距。如：12345678910111213//当line-height:xxx %时：body&#123; font-size:14px; line-height:150%; &#125;h1&#123; font-size:26px; &#125;//实际是：body&#123; line-height:21px; /* 14px*150%=21px */ &#125; h1&#123; line-height:21px; &#125; /* 继承父元素计算出来的line-height ,21px *///当line-height:x.x 时：body&#123; font-size:14px; line-height:1.5; &#125;h1&#123; font-size:26px; &#125;//实际是：body&#123; line-height:21px; /* 14px*1.5=21px */ &#125; h1&#123; line-height:39px; /* 26px*1.5=39px */ &#125; 关于css.reset文章 关于HTML默认样式表 去除inline-block元素间距的办法]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6【三】]]></title>
    <url>%2F2017%2F07%2F20%2Fi038%2F</url>
    <content type="text"><![CDATA[ES6为数组做的扩展Array.of()函数 作用：将一组值，转换成数组。 Array.from()函数 作用：可以将类似数组的对象或者可遍历的对象转换成真正的数组。 123let str = &apos;hello&apos;;Array.from(str);//结果：[&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot;] find()函数 作用: 找出数组中符合条件的第一个元素。若数组中没有符合条件的函数，则返回undefind findIndex()函数 作用： 返回符合条件的第一个数组成员的位置。若没有元素符合条件，则返回-1 fill()函数 用指定的值，填充到数组。 123let arr = [1,2,3];arr.fill(4,1,3);//结果：[1,4,4] 注意：第2个参数和第3个参数的意思是：从位置1的元素开始填充数字4，截止到位置3之前，所以是位置1和位置2的元素被数字4填充了。 entries()函数 作用： 对数组的键值对进行遍历，返回一个遍历器，可以用for..of对其进行遍历。 123456for(let [i,v] of [&apos;a&apos;, &apos;b&apos;].entries()) &#123; console.log(i,v); &#125; //0 &quot;a&quot; //1 &quot;b&quot; keys()函数 作用： 对数组的索引键进行遍历，返回一个遍历器。 123456for(let index of [&apos;a&apos;, &apos;b&apos;].keys()) &#123; console.log(index); &#125; //0 //1 values()函数 对数组的元素进行遍历，返回一个遍历器。 123456for(let value of [&apos;a&apos;, &apos;b&apos;].values()) &#123; console.log(value); &#125; //a //b 数组推导 用简洁的写法，直接通过现有的数组生成新数组。 1234var array1 = [1, 2, 3, 4]; var array2 = [for(i of array1) if(i&gt;3) i]; console.log(array2); //结果： [4] 小结 ES6为数组带来了很多很实用的方法：Array.of( )、Array.from( )、find( )、findIndex( )、fill( )、entries( )、values()，不仅如此，还带来一个更简洁的语法：数组推导，能让我们更方便地生成一个新数组。 ES6为对象带来的扩展 属性简写 12345678910111213141516171819202122232425262728var name = &quot;Zhangsan&quot;; var age = 12; //传统写法 var person = &#123; &quot;name&quot;:name, &quot;age&quot;:age &#125;; console.log(person); //结果：&#123;name: &quot;Zhangsan&quot;, age: 12&#125; //ES6写法 var person = &#123;name,age&#125;; console.log(person); //结果：&#123;name: &quot;Zhangsan&quot;, age: 12&#125;方法简写//传统的表示法 var person = &#123; say:function()&#123; alert(&apos;这是传统的表示法&apos;); &#125; &#125;; //ES6的表示法 var person = &#123; say()&#123; alert(&apos;这是ES6的表示法&apos;); &#125; &#125;; 属性名可以是表达式1234567891011121314var f = &quot;first&quot;; var n = &quot;Name&quot;; var s = &quot;say&quot;; var h = &quot;Hello&quot;; var person = &#123; [ f+n ] : &quot;Zhang&quot;, [ s+h ]()&#123; return &quot;你好吗？&quot;; &#125; &#125;; console.log(person.firstName); //结果：Zhang console.log(person.sayHello()); //结果：你好吗？ Object.is( )函数 作用: 比较两个值是否严格相等，或者说全等。 Object.assign()函数 将源对象的属性赋值到目标对象上。对象的属性出现了相同的名字,后面的属性值会覆盖前面的属性值 123456789 //目标对象let target = &#123;&quot;a&quot;:1&#125;;//源对象let origin1 = &#123;&quot;b&quot;:2,&quot;c&quot;:3&#125;;//源对象let origin2 = &#123;&quot;d&quot;:4,&quot;e&quot;:5&#125;;Object.assign(target,origin1,origin2);console.log(target);//结果 &#123;a: 1, b: 2, c: 3, d: 4, e: 5&#125; Object.getPrototypeOf( )函数 作用： 获取一个对象的prototype属性。 Object.setPrototypeOf()函数1234567891011121314151617181920212223//自定义一个Person类（函数） function Person()&#123; &#125; //函数都有一个预属性prototype对象 Person.prototype = &#123; //给prototype对象添加一个say方法 say()&#123; console.log(&apos;hello&apos;); &#125; &#125;; //实例化Person对象，赋值给变量allen let allen = new Person(); //调用类的say方法 allen.say(); //结果：打印出hello //使用Object.setPrototypeOf Object.setPrototypeOf( allen, &#123;say()&#123;console.log(&apos;hi&apos;)&#125; &#125;); //再次调用类的say方法 allen.say(); //结果：打印出hi javascript的面向对象 Javascript本身不是一种面向对象的编程语言,但可以模拟。 步骤：1、构造函数；2、给prototype对象添加属性和方法；3、实例化；4、通过实例化后的对象调用类的方法或者属性。 12345678910111213141516//构造函数模拟创建一个Dog类 function Dog(name)&#123; this.name = name; &#125; //把一些属性和方法，定义在prototype对象上 Dog.prototype = &#123; &quot;type&quot;:&quot;动物&quot;, &quot;say&quot;:function()&#123; alert(&quot;名字叫&quot;+this.name); &#125; &#125;; //实例化 var dog = new Dog(&apos;旺财&apos;); //调用say方法 dog.say(); //结果：名字叫旺财 小结 ES6给我们带来的新特性包括：简洁的表示法，属性名方法可以是表达式、Object.is( ) 函数、Object.assgin( ) 函数、Object.setPrototypeOf( ) 函数，Object.getPrototypeOf() 函数。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创业，Are you sure？]]></title>
    <url>%2F2017%2F07%2F19%2F%E5%88%9B%E4%B8%9A%2F</url>
    <content type="text"><![CDATA[创业，Are you sure？在我看来，当下的全民创业就是个笑话。《赚未来十年的钱》说的已经很纯粹了。我不知道自己以后会不会，但现在肯定没这方面的打算。事实上，也不敢有。 我在经商时，看过的所谓成功人士，也很多都是刻薄寡恩、心狠手辣之辈，对照这本书，你也可以明白，人生真的不是黑和白，而是灰色的。 几千年来人们沉迷于权力名利，不知道有几个人知道父母妻子少数朋友才是真正值得你珍爱的，爱情、亲情、友情是不可以放弃的。为了一点散碎银子、为了一点狗屎名声、为了一点权柄，就不惜父子反目、妻离子散、背后捅朋友刀子，都属于活到狗肚子里去了。 在比如周鸿祎分享关于程序员创业的看法，觉得认同： 关于程序员创业，我之所以愿意谈我的观点，是因为我是程序员出身，也是从小公司做起来的，我自认为对待很多程序员个人包括共享软件作者和一些小网站还是很好的。我希望分享一些经验和体会。 程序员创业的特别之处首先，我想说的是聪明人不一定能成功，很多程序员很聪明，但我一看就知道他们不会成功。 因为我看到了一些问题，而且现在太多程序员存在很多误解。因此，我希望把我的观点告诉程序员。或许有一些程序员能够清醒，某个人可能因为我的某一句话有了感觉，对他以后的成长产生了帮助，这就足够了。 要知道，程序员总是以为自己优秀所以就能成功，其实不是。 中国的程序员大部分是盲目的：看看一些论坛就能够感觉到，要么有一群人自我感觉极端的良好，以专家自居，要么就是一群蓝领埋怨公司和社会环境不行，待遇不好。 应该说，中国程序员创业的成功率也是很低的。放眼望去，中国互联网成功的人士有几个是真正写过十年软件的。事实上，现状和我们所能听到的媒体宣传的故事很不一样。很多程序员的最高理想就是写一个共享软件，一年可以挣几百万。但我希望谈的不是告诉程序员如何挣钱，挣钱很容易，而是要告诉程序员如何去创业。比如虽然FlashGet的作者收入很高，衣食无忧，但从创业的角度看，它并没有以商业公司的方式创业成功。 程序员在创业方面的欠缺首先，我看到中国程序员的合作心态非常缺乏，我认为这是中国程序员最大的问题，当然这是有很多原因的。 大家经常说这句话：态度决定一切。但事实上好程序员基本上都比较傲气，因为程序员往往会觉得自己在做世界上一件十分伟大的事情，这就是驱动机器，修改一行代码，机器就能够工作，可以产生各种不同的行为。这很容易会让程序员产生一种错觉，认为自己可以Control Everything。 程序员的自信在编程上是非常需要的，但不是适合一切场合。 如果我们不说这些，可能很多程序员到现在还不知道自己错在哪里，仍然认为自己是King of the World。 事实上，程序员的能力只是控制了一个机器。但创业仅仅具备了和机器打交道这一种能力是绝对不够的，他还需要和合作伙伴、竞争对手、投资人、员工甚至整个社会环境打交道。 很多程序员因为已经习惯了和机器打交道，不善于也不愿意其它的工作。很多程序员会内心认为“营销不是很简单嘛，市场很简单啊，管理也很简单啊，”我认为这种心态是非常害人的。 程序员还是一个很固执的人群，他觉得自己是机器的统帅，因此不会灵活，不会妥协。我当时也喜欢写程序，但我知道如果自己沉迷于写程序，肯定没戏，所以是逼着自己改变角色。 优秀的程序员不要自负这两天，我收到几封程序员的来信。有一封信中大意说“我是个如此优秀的程序员，为什么我就不能成功呢，请你指点。这里有我的blog地址，看完你就 会了解我了。” 我想说的是：如果真的希望别人帮忙，就要把情况真实的说出来，而不是上来就说自己很优秀，这种语言就会让别人觉得很不舒服，不是很好的交流方式。我还真看了那个blog，但看完之后，觉得这个程序员就是一个空想狂。 可以说，很多程序员实际上是优秀带来了自负，这种自负使得其不要说创业，可能在公司中工作也会遇到问题。所以，我甚至认为程序员在创业方面遇到的困难比其它类型的人员更大。如果程序员希望主导一个创业，可能首先就要逼自己不是一个程序员。 程序员应持开放心态，寻求团队合作程序员首先要学会和别人合作。 提到这点，很多程序员都会说“我正在带着其他程序员写程序啊，我会合作啊。”但这种合作是片面的，我所谈的不仅仅是程序员和程序员之间的合作，而是包括了程序员和其它各种角色之间的合作。 程序员之间的语言比较能够容易理解。但作为一个程序员，你能不能跟商业人员、销售人员很好的合作呢。 我这些年还看到很多这样的例子：程序员动不动就把目标定为比尔·盖茨。其实，比尔盖茨不应该成为程序员崇拜的目标对象，这会让程序员迷失方向，因为微软另外一个创始人保罗·艾伦才是真正的程序员。 再看其它一些例子，Google的第20名程序员都可以获得五亿美元。Adobe公司两个创始人也是一个精通技术，一个对商业精通，这样的搭配才能够更好的成功。因此，对于很多程序员来说，一定要找准真正的榜样，不要被外界的故事迷惑了头脑。 如果剖开一些故事的外表，你会发现国外很多成功的程序员，背后一定有一个很强大的商业感觉的人或者一个团队。 程序员的商业感觉其实并不是很好。即便有商业感觉，其实这只是一个灵感，一个创意，但要做成、做大还需要一系列的管理、市场、运营，这些对于程序员是不可想象的。 程序员要明白，在自己不擅长的领域，找到一个可以弥补自己缺陷的合作团队才是出路。加入一个创业团队，可能个人占10%，但因为更容易成功，而且团队可以做100分 的事情。而如果只是一个人做，很可能就失败了。 这方面，国外的程序员对自己的长短比较清楚。在硅谷，很多程序员技术上都很牛，但他们都非常知道自己只是在技术这个领域水平比较高，出了这个领域，自己什么都不是。正因为有了这种心态，他们特别懂得与人合作。我认为国外的程序员已经普遍意识到了这点，他们很愿意成为创业团队中的一员而并非自己创业。 因此，程序员需要调整心态，不要把自己当作精英人物，要承认自己在编程方面是优秀的，但永远有人比自己更优秀，对于其它的领域，很可能自己很无知。要知道，其实程序员所涉及的领域很窄，因此抱有开放的心态是最重要的。 程序员与创业要求还有哪些差距我认为现在的很多程序员经验过于不足，他没有认真踏实做过很多工作就奢谈创业。如果一个程序员没有在编程方面深入过，没有积累，也就是半瓶子醋。这样的程序员我接触过很多，他们自己也不清楚问题出在哪里，让人感觉又爱又恨。我认为程序员既然要凭借自己的技术，那就一定要踏实，要能够实现任何创意。 但现在一些程序员自己没有商业意识，却又很自负，不相信别人，不理解的事情就不做。我遇到过很多程序员，他们对公司做什么方向都质疑。他们希望自己先想清楚，可是一想就浪费了很长时间。 很多程序员就可悲在这里，积累的不多，看不到方向，但他也不相信自己的公司和老板，这是一个悖论，需要程序员深刻反省。要知道，每个公司都有懂商业的人。 就这样，一些程序员极端自负，另外有一些程序员碰了很多钉子之后，感觉很自卑，于是便认为国内软件业不行，最后出国或者打工，很少有程序员能对自己做出公正的评价。 国内环境是否造成程序员浮躁的因素我以前没有仔细考虑过这点。但我想，不管怎样，程序员需要先从自身找问题，因为大环境就是这样了。我承认一个现实：程序员生存状态并不是很好，但程序员很多报怨其实是一种不切实际的期望值和自身的缺陷产生的反差。 首先，产品没有大小，只有市场的大小。很多人总是觉得这也小，那也看不上。认为公司做的产品很无聊，要做就要像某些人宣扬的那样：做游戏一定要做3D引擎，好像只有这样才够牛。 这其实就是一种浮躁。很多程序员写软件总是很多bug，基础知识也不牢固，没有参加几个项目，没有写过十万行代码，就奢谈做大项目，这有价值吗？ 而且我还发现有些程序员特别愤青，骂环境，骂老板，其实这只能把自己的心态搞的很坏。很多人刚进公司时做的很差，虽然工资少，但他没有想到给公司增加了很多bug，公司实际上是在给他出学费。论坛上大家都在讨论哪里活干得少钱拿的多。甚至还有人列了一些黑名单。这种做法的结果就是程序员自己将周围环境搞的乌烟瘴气了。 有的程序员还非常喜欢指点江山，指点公司。我个人觉得这不是不可以，但指责别的公司对个人没有什么好处，因为存在就是合理的。如果看不到，恰恰证明是自己看不到。我看到很多程序员也写blog，技术交流的我认为非常好，但有些人是写评论。我是觉得程序员不要做评论家，中国不缺评论家，最缺的是实干家。 总之，程序员一般过于自我。总生活在自我的世界中，就不可能真正了解世界是什么。我很早就意识到了这些问题，也努力的去克服。我的经验就是看别人如何做的好，为什么能够做的好，什么是我所不能理解。程序员要学会慢慢站在别人立场上看问题。 最后给希望创业的程序员一点建议对程序员来说，现在要做的也很简单，这就是需要大量的实践，要慢慢培养对产品，对商业的感觉。 我的建议说出来可能有些忠言逆耳。对绝大多数程序员来说，自己一个人成功的机率是很小的，所以我认为加入一个创业的团队可能更为合适。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《认知突围》]]></title>
    <url>%2F2017%2F07%2F16%2Fb007%2F</url>
    <content type="text"><![CDATA[什么是均值回归均值回归，指的是无论是低于或高于真实价值的状态，都有向真实价值回归的趋势，其回归趋势的强度就类似于弹簧，偏离中心越远，强度就越大。 认知清单 我们的大脑不靠谱，我们惯用切片思维，为了获得更好的情绪体验，我们会创造自我，自欺欺人。 我们的记忆是被自我意识改造过程后的记忆。 我们对自己的评价总是构建在其他反馈的基础之上，所以我们不是不会客观地评价自己，而是不想客观地评价自己。 懒惰、放纵、自制力不足，根源都在于认知能力受限，看不到某事物能带来的巨大收益，因此就不足以产生足够的动力。广义上来讲，认知也是一种智慧。 机会并没有那么依赖运气，机会之所以没有青睐你，是因为你并不具备开启它的条件。 先做起来，让自己变得更好，“意外好运”才有更大的概率降临。 势力是刻进人类基因里的，它并不是一个贬义词，势力贯穿了人类各种行为的始终。 获得好人缘的正确方式是拥有更多的正面资源。 知识层次 底层知识是最基础的信息知识。 第二层知识叫加工知识。 第三层知识叫体系知识。 最高一层，也是最难得到的就是智慧了。 扯扯人生 人生没有起跑线，也没有假想的跑道。如果要用游戏来表示，应该是一个自由度最高的游戏。 人生最大意义在于体验，总是体验重复和 相似的风景，其实在人生的时间利用率上是吃亏的。 说不想努力的人，不是不想要努力后的结果，而是惧怕努力要付出的成本。 努力有着许多“坑”，并非仅是看上去努力就能达成目标。 很多“坑”是达到一定高度前不可避免的，那么踩“坑”其实是越早越好，越早损失越少。 格局是每个人的认知层次，下层没法看清上层的世界。 学习和职场一样，长期来看，都是专注自身最划算。 提升格局首先要勇于打破自己的积累，看得到往上有更高层次。 合理分配投资和消费的比例，合理安排投资和消费的时间点，是提高人生使用效率的两大关键。 幸福源于比较，但不论是跟他人比较还是跟自己比较，这都是大脑能调整的事。 什么是知识能被称为知识的必须满足以下条件，即客观的，能被验证的，相对正确的。 情商最终情商的高低，是以有没有达到你预想的目标为依据的，而不是以你有没有做些特定的事为判定准则的。 如何对待金钱 人格决定钱格，金钱影响道德。 渴望程度决定努力车程度，正确方向上的努力程度决定成绩。 花钱比省钱更符合道德标准。 无节制地省钱是错误的金钱观，无节制地花钱也一样。 在开源和节流产生冲突的时候，通常情况下，坚定地站在开源这一边。 不同种类的劳动，产生的价值当然是不同的，但考虑到边际，同样劳动产生的价值也是不同的。 不可替代性和稀缺性才是最大的价值，而金钱是这种价值的外在表现形式。 让别人挣到钱就是让自己挣到钱。 风险盈利并不等同于赌博，风险思维是一种策略，赌博思维是纯凭运气。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[假如我有100W]]></title>
    <url>%2F2017%2F07%2F12%2F100W%2F</url>
    <content type="text"><![CDATA[如果你也认为仅凭勤奋和诚实就能获得财富，赶紧打消这种想法吧！它是错误的！巨额财富向来都不是靠努力勤奋得来的！如果可以得到财富，那么它必定是明确需求的回应，基于应用明确的原则而得来，完全不是依靠运气或机会！ 如果这个条件存在，那么我会留5万应急，5万带家人游玩一圈。比如，去西藏、云南等等。剩下的90万用于投资，比如买商铺，但绝对不会买住宅，车也不会。要开车，我可以租，事实上，自己花钱买一辆车也无非自己在自己手上租了一辆罢了。我始终相信一点，就是“有钱一定有车，但有车不一定有钱”。 有时候，我问自己，自己赚100W需要多长时间，5年？还是更长时间。曾看过一句话，说你要想赚100万就要忍受价值100万的代价。 机会是留给有准备的人的，祝自己好运，可以通过自己的努力尽快实现这个小目标？？？]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端构建工具]]></title>
    <url>%2F2017%2F06%2F28%2F%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7%2F</url>
    <content type="text"><![CDATA[任何能用JavaScript实现的应用系统，最终都必将用JavaScript实现。 首先先看篇文章 包管理和构建工具都需要依赖关系 Grunt与Glup本质而言都是为了更好更快的完成开发任务。 Grunt自身缺陷 配置项过多。每一个插件的使用都需要配置输入项和输出项，使用比较繁琐。 子任务间的协作基于文件。基于文件的坏处是，后一个子任务必须等前一个子任务的过程完全结束，才能开始它的流程，这样比较慢。而且磁盘读写速度远远慢于内存读写。 这是Glup便诞生了。 Glup优势 易于使用：采用代码优于配置策略，gulp让简单的事情继续简单，复杂的任务变得可管理。 高效：通过利用node.js强大的流，不需要往磁盘写中间文件，可以更快地完成构建。 高质量：gulp严格的插件指导方针，确保插件简单并且按你期望的方式工作。 易于学习：通过把API降到最少，你能在很短的时间内学会gulp。构建工作就像你设想的一样：是一系列流管道。 说了这么多，关键还得实施啊，那就从现在开始学习Glup吧！]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[今天咋也来谈谈EQ]]></title>
    <url>%2F2017%2F06%2F25%2FEQ%2F</url>
    <content type="text"><![CDATA[简单来说，情商（情绪智力）是指识别、理解自己和他人的情绪状态，并利用这些信息来解决问题和调节行为的能力。 情商高的人通常都擅长处理情绪，在大多数时候能做到头脑冷静、行为理智，保持愉快的心情，因此情商高的人不仅更容易受他人的欢迎，也更有可能获得成功。 本测评根据你在情绪觉察、情绪管理、情绪驱动、情绪理解和社交技巧五个方面的表现，综合评估你的情商指数，有助于你更好地管理自己的情绪，获得和谐融洽的人际关系。 情商指数水平：较高你的情绪智力指数较高，你能够妥善地处理自己的情绪，也能够合理地面对他人的情绪，在社会中能够自在地与各种各样的人相处，很少有与人闹得不愉快的情况。 影响因素情绪智力剖析图 情绪觉察你的结果：一般你的情绪觉察能力一般，一般情况下你能辨别自己的情绪，但是偶尔你也判断不出这些情绪因何而起。你有时想给别人留下某种特定的印象，但是结果却出乎你的意料。 情绪管理你的结果：较强你的情绪管理能力较强，你能较好地处理自己的情绪，面对突出其来的强烈情绪可以较好地转移或消解，即使在压力下，也能够可以保持清醒，较快地从生活的挫折和烦恼中恢复。然而情绪管理的技巧你也没有完全熟练，偶尔就算意识到自己的不良情绪也不能很好地转移或消解。 情绪驱动你的结果：较强你的情绪驱动能力较强，你能够进行自我激励，感到自己有能力找到实现目标的方法，无论目标是什么，都相信自己有决心而且有能力实现。你的自我激励水平随着你对工作的认可程度而变化，当你不满意自己的工作内容或待遇时，你会拒绝付出太多的激情去做事。 情绪理解你的结果：较强你的情绪理解能力较强，你比一般人更善于察觉他人的情绪感受，愿意倾听他人的烦恼，能够设身处地的理解他人的感受。尽管你的同情心比一般人强，但是有时你还是不能理解别人做出一些奇怪的决定或行为的原因。 社交技能你的结果：一般你的社交技巧一般，在如何与他人相处这门必修课上，你掌握的技巧并不多。你在与人相处时偶尔会发生一些得罪人的情况，有时你也搞不清楚自己为什么得罪了别人。 情商结论 你的情绪智力指数较高，表明你是一个有魅力的人，在他人眼中你是称职的合作伙伴、值得信赖的伴侣。在人际交往方面，你善良，在适当的时候能够对他人施以援手，有选择地关怀他人，不管是在什么社交场合，你都表现得自信从容，容易给别人留下良好的印象，赢得他人的认可和支持。 在情绪处理方面，你懂得合理地表达自己的真实感受，有技巧地处理压力和冲突，能够保持冷静、随机应变，不过面对一些尴尬的社交局面你也有束手无策的时候。 在工作与生活方面，你有着较强的掌控能力，比较了解自己应该从事什么样的工作，适合什么样的伴侣。 ☆ 你对情绪的觉察能力一般，表明你对自己的情绪不太敏感，有时会陷入莫名其妙的情绪当中，比如突如其来的愤怒或忧伤等。 你有时会有难以准确描述自己的情绪感受的状况，不善于表达自己的情绪，在选择表达情绪的方式和场合时可能会出现错误。 在人际交往中，你的情绪不太稳定，容易激动，行为不够理智，容易被情绪支配，做出让自己事后回想起来后悔的事。 ☆ 你的情绪管理能力较强，表明你能够调节和处理自己的情绪，在压力面前，能够通过一定的方法让自己保持冷静和理智，不会轻易被情绪所控。 你是自己情绪的主人，你懂得在合适的时间、地点，用合适的方式表达情绪，以比一般人更为乐观的心态面对生活中出现的困难和挫折，能够自己缓解紧张、焦虑、沮丧、愤怒等不良的心理状态。 在人际交往中，你显得比较成熟，懂得设置自己的界限，能够坚持自己的立场和原则。遇到不公平的对待时，能够表达自己的态度，有驱散紧张尴尬的气氛的能力，但是有时不够灵活。 ☆ 你的情绪驱动能力较强，表明你有一定的内在动力，你能够为了满足自己内心对成功的渴望，通过一定的努力，把事情做得更好。 你是一个行动派，当你从事你感兴趣的工作时，总是能专注于当前任务，发自内心地认真和负责，对不断变化的任务要求反应自如。 你在遇到逆境时能坚持，调整情绪，恢复活力，具有较强的心理韧性。 在别人眼中，你是一个有上进心、进取心的人，对生活和工作都保持一定的热情，知道如何调动自己的积极情绪，能够发挥自己的潜能。 ☆ 你的情绪理解能力较强，表明你有较好的观察力，能够准确地感知和识别他人的情绪和身体语言。 你和别人打交道不会有太大的困难，因为你能领会他人的反应和感受，并且可以通过观察别人的非语言信息，如：身体动作、面部表情和眼神交流等，感知到别人细微的情绪变化。 你能够认真倾听和理解他人的处境和困扰，并考虑他人的情绪感受，提供有价值的信息反馈，获得他人的信任。 在人际交往中，你具有同情心，即使与自己的观念不一致的人也能和平相处。当你察觉到别人的真正需要，会主动劝服和安慰别人。尽管遇到你不能理解的人，你也能想到人无完人，不过分苛求。 ☆ 你的社交技巧水平一般，表明你在建立和维护与周围人的关系上表现一般，有时会导致一些人际冲突。 由于你在判断应该在什么场合什么时间下说什么、做什么、会对别人有什么影响的时候准确性不足，导致你的人际交往不太顺畅。 在人际交往中，你显得不太合群，不懂得察言观色，也不知道如何与陌生人闲聊，待人接物的能力有待提高，可能会造成别人的疏远或排斥。 提升建议 ☆ 你的情绪觉察能力弱，针对你的情绪觉察能力，建议你先学会了解并接纳自己的情绪。 每当自己觉得思绪混乱，情绪快要失控的时候，先学会冷静下来，转移注意力，不要让情绪赶走你的理性，事后在纸上写下你刚才的想法，并加以评论。看看自己刚才是感到的哪一种情绪以及自己为什么会有这样的情绪。 将你的想法从头脑中的搬到纸上，是将抽象的观念具体化的过程，这样能让你对自己的情绪有更加清晰的认识，而不是在脑不是在脑子里被追得团团转。 ☆ 你的情绪管理能力较强，表明你是一个能够熟练地处理情绪的人。如果你想进一步增强你的情绪管理能力，当你发现自己存在不良的情绪，你可以寻找合理的渠道宣泄。 例如适当地向朋友家人倾诉或自己消解；当你发现自己在不适当的时候出现了不适当的情绪时，可以选择转移自己的注意力，想想其他事情，让自己迅速冷静下来。 ☆ 你的情绪驱动能力较强，表明你有进取心，容易成为一个出色的领导者。如果你想进一步增强你的情绪驱动能力，你可以从选择一份让你感觉到“有价值”的工作开始。 当你发现自己缺乏前进的动力时，不妨停下来稍作休整，旅行、烹饪、玩游戏，这样你更容易找回朝着梦想前进的热情和动力。 ☆ 你的情绪理解能力较强，表明你能够较好地察觉他人的情绪和感受。如果你想进一步提强你的情绪理解能力，你可以更进一步地提强换位思考的能力。 当你不能理解他人的做法时，你可以做出更多的尝试和努力去理解，比如设想自己站在别人的位置上会怎么做，比如多接触这个你不理解的人，了解他真正的想法。 你的社交技巧水平一般，表明你与人建立融洽关系的能力不足，人际关系一般。针对你的社交技巧水平，建议你学一些待人接物的技巧，提高自己受欢迎的程度。 在与人交谈时，可以多说一些贴心的话，如：“你过得如何？”“你感觉怎样？”“你真好”“和你在一起我感觉很开心”“非常感谢你的帮助”“很抱歉，给你添麻烦了”等，同时配合积极的眼神接触和微笑。 平时在生活中，可以多观察别人的需要，提供及时的帮助和支持。提供食物或饮料、一张个性化的卡片、一个体贴的礼物、一个需要支持、移情清单、参与共同创建一种更亲密关系的活动。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[几部老电影]]></title>
    <url>%2F2017%2F06%2F22%2Fmovies%2F</url>
    <content type="text"><![CDATA[人的一生何尝不是一部电影，或精彩或平凡。都是自己的。正如玉伯说的： 一个人的成熟，可以看他是否已经从内心去除「对与错」、「好与坏」、「成与败」，要彻底拔除「攀比」之心 ，虽然很难很难。马云成功吗？这句话是一个鱼饵。你尝试去回答它，就意味着你默许了背后的价值观。 「默许」很可怕。 长在中国的人，大都成为了唯物的无神论者，再去看唯心的一些观点时，往往内心深处已经「默许」了唯心是错的。控制教育，就控制大部分人的思想，政治非常非常禁锢人性、人心。从小的意识灌输，甚至会让长大的你，即便辨识到自己的有些想法可能是错的，但却很难很难再纠正这些从小就形成的想法。 肖申克的救赎教父狼牙我很少关注明星，在我眼里，他们的生活与我无关。喜欢吴京也是因为这部电影，这是我高中时期最爱看的。之后的战狼系列对我来说触动并不是特别大。这种事情，不强求，随心就好。 在我眼中，区分一部电影的好坏在于看完后让我懂得【明白】了什么。不想某些XX大牌的电影，一堆狗血剧拼凑成的，毫无意义。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>Movies</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue【二】]]></title>
    <url>%2F2017%2F06%2F10%2Fvue2%2F</url>
    <content type="text"><![CDATA[定义一个Vue实例常用的4个选项filter过滤器12345filters:&#123; toInt(value)&#123; return parseInt(value); &#125;&#125; computed计算属性12345computed:&#123; sum()&#123; return this.num1+this.num2+this.num3 &#125;&#125; methods方法12345methods:&#123; plus()&#123; return this.a++; &#125;&#125; watch 观察123456watch:&#123; a()&#123; console.log(`有变化了，最新值：`); console.log(this.a); &#125;&#125; 生命周期]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript模块化加载器]]></title>
    <url>%2F2017%2F05%2F29%2Frequire%2F</url>
    <content type="text"><![CDATA[常听人说require.js，这是干啥的。无奈。require的出现主要解决2个问题。 实现js文件的异步加载，避免网页失去响应； 管理模块之间的依赖性，便于代码的编写和维护。 1&lt;script src=&quot;js/require.js&quot; defer async=&quot;true&quot; &gt;&lt;/script&gt; async属性表明这个文件需要异步加载，避免网页失去响应。IE不支持这个属性，只支持defer，所以把defer也写上。 加载require.js以后，下一步就要加载我们自己的代码了。假定我们自己的代码文件是main.js，也放在js目录下面。那么，只需要写成下面这样就行了： 1&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/main&quot;&gt;&lt;/script&gt; data-main属性的作用是，指定网页程序的主模块。在上例中，就是js目录下面的main.js，这个文件会第一个被require.js加载。由于require.js默认的文件后缀名是js，所以可以把main.js简写成main。 AMD模块的写法具体来说，就是模块必须采用特定的define()函数来定义。如果一个模块不依赖其他模块，那么可以直接定义在define()函数之中。 假定现在有一个math.js文件，它定义了一个math模块。那么，math.js就要这样写： 123456789// math.js define(function ()&#123; var add = function (x,y)&#123; return x+y; &#125;; return &#123; add: add &#125;; &#125;); 加载方法如下： 1234 // main.js require([&apos;math&apos;], function (math)&#123; alert(math.add(1,1)); &#125;); 如果这个模块还依赖其他模块，那么define()函数的第一个参数，必须是一个数组，指明该模块的依赖性。 12345678define([&apos;myLib&apos;], function(myLib)&#123; function foo()&#123; myLib.doSomething(); &#125; return &#123; foo : foo &#125;; &#125;); 当require()函数加载上面这个模块的时候，就会先加载myLib.js文件。 参考文章]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[商城项目]]></title>
    <url>%2F2017%2F05%2F27%2F%E5%95%86%E5%9F%8E%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Preview: https://webykj.github.io/Shop 一个网站中常用到的特效：轮播图、TAB切换、手风琴、滚动字幕、3级联动、弹出层等等。该项目用到了滚动字幕、TAB切换、轮播图、无缝轮播、星星评价等网页常用特效。也用到了一个图片放大插件。最大的特色就是特效全部都是自己写的。 开发中遇到的问题1.clearfix&#123;overflow:auto; _height:1%;&#125; 这不就是清除浮动吗？有什么好说的。先别急，让我说完。 解决方案嘛，也很简单： 1.clearfix&#123;overflow:hidden; _zoom:1;&#125; 但这样又会遇到这样一个问题，当你导航有下拉菜单时，由于使用了overflow:hidden;使得下拉菜单无法显示。所以，还是老老实实用常规伪类清浮吧。 项目收获： 明白了项目架构的重要性，看似仅仅只有几个页面，但考虑到后期改版、维护的话就不是这样了； 加深了对JavaScript的理解； Tab切换核心代码12345$(this).addClass(&apos;active&apos;).siblings().removeClass(&apos;active&apos;);for(var i=0;i&lt;3;i++)&#123; $(&apos;#content div&apos;).eq(i).css(&apos;display&apos;,&apos;none&apos;);&#125;$(&apos;#content div&apos;).eq($(this).index()).css(&apos;display&apos;,&apos;block&apos;); 滚动字幕核心代码123var lineHeight=-($(ele).find(&apos;li:first&apos;).height());$(ele).animate(&#123;&quot;marginTop&quot;:lineHeight+&quot;px&quot;&#125;,600,function ()&#123;$(this).css(&#123;marginTop:0&#125;).find(&apos;li:first&apos;).appendTo(ele)&#125;); 无缝轮播核心代码1234567$(&quot;.oraign&quot;).clone().appendTo(&apos;.list&apos;);if( !$(&apos;.list&apos;).is(&quot;:animated&quot;) )&#123; if($(&apos;.list&apos;).css(&apos;left&apos;)==&apos;-3294px&apos;)&#123; $(&apos;.list&apos;).css(&#123;left:&apos;-0px&apos;&#125;,500) &#125; $(&apos;.list&apos;).stop(true,true).animate(&#123;left:&apos;-=&apos;+$width&#125;,500)&#125; 项目总结：写的就是一坨屎，正因为这样，才让自己有动力不断完善。用最少的代码实现业务需求。减少代码冗余，实现代码的复用，提高开发效率。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CPU占比探测]]></title>
    <url>%2F2017%2F05%2F13%2Fi030%2F</url>
    <content type="text"><![CDATA[实现原理： 12345678910var data = []var tfunction pulse() &#123; t &amp;&amp; data.push(Date.now() - t) t = Date.now() setTimeout(pulse, 50)&#125;pulse() 理想情况下，data=[50,50,50…],实际可能是[50,54,53,50,53…],在CPU较高时，数据可能变成[50,60,100,87…]]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《赚未来十年的钱》]]></title>
    <url>%2F2017%2F05%2F09%2Fb005%2F</url>
    <content type="text"><![CDATA[《赚未来十年的钱》如果你没过这本书可能认为只是本鸡汤书，其实，我没看之前也是这样认为的。但你读后，你会发现自己错了。并不是自己想的那样。强烈推荐。这本书是今年我看的所有书里面让我感触最深的！作者在经历了人生的三起三落后，从此人生走向正轨。我欣赏作者的魄力。其实，我把他当做我的偶像。恩，对，就是这样，下面进入正题。 人在年轻时候的苦不是苦，老来苦才真的可怕。 年少时的苦是历练，年老时的苦是凄惨，少一些抱怨，多一些努力付出比什么都重要。 与家人之间的关系人临死前才知道谁是对他最重要的人，希望儿子握着他的手，让他没有遗憾地死去。儿子泪流满面。 曾经，我有父亲的关系总是微妙的，这个情况在高考过后尤为激烈，由于高考失利，家人希望我复读，可我说什么也不复读，其中的难言之隐无法为外人道知。而现在，我很少与父亲争吵，觉得不值得，有什么坐下来好好沟通，即使有分歧，也不非得分个对错，父子之间是不存在什么对错的。都是彼此牵挂着对方。 什么是自由要自由首先要财务上的自由，财务上的自由首先要精神上的自由，精神上的自由要有足够的智慧看懂世界，有足够的勇气承担风险。 这里的自由归根揭底说得是对风险的把控，风险与收益永远都是正比例关系，世上哪有什么低风险高收益，除非是你自己在意淫。 套路与被套路中介的生意经是自古以来就有的，玩弄信息不对称和口才、心理。这就是很好的生意了，也没什么大的成本，租金而已。 感觉作者豁达，看得如此透彻，想想也当然如此，在生意场拼搏多年，这些都早已是家常便饭了。向这位伟大的作者致敬，哈哈~~ FreedomtochooseFreedomtochoose，我要掌握一生自决，不依靠任何人，除了妻女的爱，除了父母的爱，还有什么是我需要的吗？ 那样就足够了，这个冷酷的世界。 世上好人还是有的，只不过在庞大的人口基数面前便成为了毛毛雨了。 如何看待社会上的不公平社会的确不公平，从你出生的那一刻起，你就处在不公平中；但是，如果等你死的时候，你还在抱怨不公平，那你的一生就是失败的。 什么是真本事真正值得获得的是真本事——专业技能和人脉、财商——理财的能力。 真本事往往需要在一个行业沉下气，深耕细作，既学习专业知识，也扩大人际网络；而财商难得多，需要了解世界运转的各个方面，从政治哲学、经济学、心理学、金融实务、财会基础知识到社会现实的理解能力。 生意场生意场是个丛林。 赤裸裸的，没有同情，没有软弱，没有犹豫迟疑。左边是狼，右边是虎，脚下荆棘里游动着无数毒蛇，而秃鹫在天空中翱翔，寻找将死之人的死亡气息。 同样，任何一个行业都是如此，只不过生意场更为严峻罢了。这就需要我们努力提升自己，成为不可替代的人，或者说，替代的成本远大于再次招聘的成本。这时，话语权就在自己手上了。 我在经商时，看过的所谓成功人士，也很多都是刻薄寡恩、心狠手辣之辈，对照这本书，你也可以明白，人生真的不是黑和白，而是灰色的。 几千年来人们沉迷于权力名利，不知道有几个人知道父母妻子少数朋友才是真正值得你珍爱的，爱情、亲情、友情是不可以放弃的。为了一点散碎银子、为了一点狗屎名声、为了一点权柄，就不惜父子反目、妻离子散、背后捅朋友刀子，都属于活到狗肚子里去了。 作为创业者，要注意的几个要点是： A.起家的成本不能高。比如你不能上来就租赁办公室，如果是店铺则例外；不要急于注册公司，注册公司的成本极高，而且繁琐。等你慢慢起步有了现金流之后，再注册公司和寻找办公室雇用员工。 B.一切重点是现金流。现金流的正常流动，可以支撑你生存和扩展生意，如果你的现金流断裂，哪怕你的生意前景再好，你也会倒闭失去一切机会。所以在这当中，你要不惜一切代价维持现金流，哪怕是亏本。 当然你不能永远不赚钱，就像国美、京东商城可能营业不赚钱，但是巨大的现金流足以让他们活到产生大量利润的时刻。 C.找到市场的缝隙。任何市场都有机会，即使是在生产过剩，恶性竞争的时代。比如我曾经重新起步时做二手房翻新，在竞争加剧时及时转向到老建筑翻新。而在房地产市场萧条，老建筑翻新私人市场也竞争泛滥的时候，我已经能够有能力建立网络公司来进入另一个市场。而新的市场也是一个利基市场，竞争乏力。 D.融资。对于创业者，解决资金的问题有几种办法：银行贷款，私人借贷，供应商信用赊账。 其中银行贷款这种馅饼是不会掉在我们这样的小民营企业身上，银行贷款大量地流向效率缓慢的国有企业和少数大亨级的私营富豪。 关于创业，我不知道自己会不会走这条路，索性就先收录下来吧！这里，作者谈到了现金流的重要性，现阶段的我没法体会到，也就没什么观点存在了。 最后一首诗，与君共勉我是不会选择做一个普通人的。 如果我能够做到的话，我有权成为一位不寻常的人。 我寻找机会，但我不寻求安稳。 我不希望在国家的照顾下成为一名有保障的国民。 那将被人瞧不起而使我感到痛苦不堪。 我要做有意义的冒险。 我要梦想，我要创造，我要失败，我也要成功。 我拒绝用刺激来换取施舍； 我宁愿向生活挑战，而不愿过有保证的生活； 宁愿要达到目的时的激动，而不愿要乌托邦式毫无生气的平静。 我不会拿我的自由与慈善作交易，也不会拿我的尊严去与发给乞丐的食物作交易。 我决不会在任何一位大师面前发抖，也不会为任何恐吓所屈服。 我的天性是挺胸直立，骄傲而无所畏惧。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery中的事件冒泡]]></title>
    <url>%2F2017%2F05%2F06%2Fi039%2F</url>
    <content type="text"><![CDATA[什么是冒泡1234&lt;div id=&quot;content&quot;&gt; 外层div元素 &lt;span&gt;内层span元素&lt;/span&gt;&lt;/div&gt;&lt;div id=&quot;msg&quot;&gt;&lt;/div&gt; 当点击span元素时,会输出内层span元素被点击，外层div元素被点击，body元素被点击3条记录。这就是由于事件冒泡引起的。 冒泡过程 停止事件冒泡123456$(&apos;span&apos;).bind(&apos;click&apos;, function (event) &#123; //event:事件对象 var txt = $(&apos;#msg&apos;).html() + &apos;&lt;p&gt;内层span元素被点击&lt;/p&gt;&apos;; $(&apos;#msg&apos;).html(txt); event.stopPropagation(); //停止事件冒泡&#125;);//这样点击span时，只会输出1条记录。 阻止默认行为 event.preventDefault(); 可以改写为：return false;也可以把事件冒泡中的event.stopPropagation(); 改写为：return false; $(function () { $(ele).bind(&apos;click&apos;, function (event) { var username = $(&apos;#username&apos;).val(); //获取元素的值 if (username == &quot;&quot;) { alert(&apos;文本框的值不能为空&apos;); //event.preventDefault(); //阻止默认行为（表单提交） return false; } }); }); 事件捕获 参考文章1 参考文章2]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6【二】]]></title>
    <url>%2F2017%2F04%2F28%2Fi037%2F</url>
    <content type="text"><![CDATA[解构赋值 ES6允许按照一定格式，从数组和对象中提取值，对变量进行赋值，这就被称为解构。 数组的解构赋值 解构赋值可嵌套 1var [a,b,c]=[1,2,3] 不完全解构，在解构赋值中，赋值失败，变量的值变成undefined,不会抛出异常。 1var [a,b,c]=[1,2] 允许设定默认值 当新值为undefined时，不会覆盖默认值 1var [a,b,c=3]=[1,2,4] //可被覆盖 对象的解构赋值12var [a,b,c]=&#123;&quot;a&quot;:1,&quot;b&quot;:2,&quot;c&quot;:3&#125;//对象的解构赋值不会受到属性排序的影响，数组则会受影响。 可被嵌套 1var &#123;a:&#123;b&#125;&#125;=&#123;&quot;a&quot;:&#123;&quot;b&quot;:1&#125;&#125; 可以设定默认值 1var &#123;a,b=2&#125;=&#123;&quot;a&quot;:1&#125; 字符串的解构赋值1var [a,b,c,d,e]=&quot;我是攻城狮&quot;; 解构赋值用途 交换变量的值 123var x=1;var y=2;[x,y]=[y,x] 提取函数返回的多个值 1234function ()&#123; return &#123;&quot;name&quot;:&quot;张三&quot;，&quot;age&quot;:21&#125;&#125;var &#123;name,age&#125;=demo(); 定义函数参数 123456function (a,b,c)&#123; console.log(&quot;name&quot;+a); console.log(&quot;age&quot;+b); console.log(&quot;sex&quot;+c);&#125;demo(&#123;a:&quot;张三&quot;,b:&quot;21&quot;,c:&quot;man&quot;&#125;) 设定函数参数的默认值 1234function (&#123;age=21&#125;)&#123; console.log(&quot;年龄&quot;+age);&#125;demo(&#123;&#125;) 小结 解构赋值是一种全新的变量赋值方式，主要可利用数组解构赋值和对象解构赋值，主要用途：交换变量值，提取函数返回值，函数参数定义，默认值设定等。 ES6字符串新特性 ES6给字符串带来了很多实用性的扩展：模板字符串，标签模板，repeat函数、includes函数，startsWith函数，endsWith函数，codePointAt函数，String.fromCodePoint函数，String.raw函数。 模板字符串123456let name = &quot;Jacky&quot;;let occupation = &quot;doctor&quot;;let str = `He is $&#123;name&#125;,he is a $&#123;occupation&#125;`;//不再需要通过+，“”进行拼接了let str = `write once , run anywhere`; ${ }中可以放任意的javascript表达式，如运算表达式，对象的属性，函数的调用。repeat函数 repeat( )函数：将目标字符串重复N次，返回一个新的字符串，不影响目标字符串。 includes函数 判断字符串中是否含有指定的子字符串，返回true表示含有和false表示未含有。第二个参数选填，表示开始搜索的位置，从0开始。 startsWith函数 判断指定的子字符串是否出现在目标字符串的开头位置，第二个参数选填，表示开始搜索的位置。 endsWith函数 判断子字符串是否出现在目标字符串的尾部位置，第二个参数选填，表示针对前N个字符。 codePointAt函数与String.fromCodePoint函数String.raw函数 返回字符串最原始的样貌，无视转义符的存在。 什么是Unicode编码 Unicode（中文：万国码、国际码、统一码、单一码）是计算机科学领域里的一项业界标准。它对世界上大部分的文字系统进行了整理、编码，使得电脑可以用更为简单的方式来呈现和处理文字。 ES6数值新特性 传统isNaN会将非数值转化为数值在判断，而Number. isNaN只对数值类型有效，其余类型一律返回false 12console.log(isNaN(&apos;abc&apos;)); //trueconsole.log(Number.isNaN(&apos;abc&apos;)) //false 使用Number.isNaN是要注意，返回false时，不一定就是一个数值，有可能是一个非数值类型的参数。 Number.isFinite函数 用来检查一个数值是否非无穷。对，真就是假，假就是真。 123console.log(Number.isFinite(1)); //trueconsole.log(Number.isFinite(Infinity)); //falseconsole.log(Number.isFinite(&apos;abc&apos;)); //false 注意：与Number.isNaN一样，Number.isFinite函数返回false的时候，参数不一定就是一个有穷的数值类型，也有可能是一个非数值类型的参数。 Number.parseInt函数 解析一个字符串，返回一个整数，作用无任何变化。 Number.parseFloat函数 解析一个字符串，返回一个浮点数，作用无任何变化。 Number.isInteger函数 用来判断是否是一个整数，这里要注意一点，若小数点后都是0的浮点数，返回都是true 极小常量【约等于0.00000000000000022204】用来计算误差，若误差小于这个数，表示误差可被接受。 安全整数 能够准确表示的整数范围在-2^53到2^53之间 ES6Math对象扩展Math.trunc函数 用于去除一个数的小数部分，返回整数 Math.sign函数 用于判断一个数是整数，负数，还是0。非数值类型的参数返回NaN 1234Math.sign(3); //结果：1Math.sign(-3); //结果：-1Math.sign(0); //结果：0Math.sign(&apos;abc&apos;); //结果：NaN Math.cbrt函数 用于计算一个数的立方根。 其他一些函数Math.acosh(x) 返回 x 的反双曲余弦。Math.asinh(x) 返回 x 的反双曲正弦。Math.atanh(x) 返回 x 的反双曲正切。Math.clz32(x) 返回 x 的 32 位二进制整数表示形式的前导 0 的个数。Math.sinh(x) 返回x的双曲正弦。Math.cosh(x) 返回 x 的双曲余弦。Math.expm1(x) 返回 e?x - 1。Math.fround(x) 返回 x 的单精度浮点数形式。Math.hypot(…values) 返回所有参数的平方和的平方根。Math.imul(x, y) 返回两个参数以 32 位整数形式相乘的结果。Math.log1p(x) 返回 1 + x 的自然对数。Math.log10(x) 返回以 10 为底的x的对数。Math.log2(x) 返回以 2 为底的 x 的对数。Math.tanh(x) 返回 x 的双曲正切。 小结 ES6对Number对象新增了isInteger函数、极小常量Number.EPSILON、安全整数。将window对象下的4个函数【Number.isNaN Number.isFinite Number.parseInt Number.isInteger】移植到了Number对象。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Gulp的目标是取代Grunt]]></title>
    <url>%2F2017%2F04%2F01%2FGrunt%2F</url>
    <content type="text"><![CDATA[它努力要实现特性： 易于使用：采用代码优于配置策略，gulp让简单的事情继续简单，复杂的任务变得可管理。 高效：通过利用node.js强大的流，不需要往磁盘写中间文件，可以更快地完成构建。 高质量：gulp严格的插件指导方针，确保插件简单并且按你期望的方式工作。 易于学习：通过把API降到最少，你能在很短的时间内学会gulp。构建工作就像你设想的一样：是一系列流管道。 那还等什么，现在开始就开始学吧！ Glup的学习]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Web App、Hybrid App、 Native App各自优缺点]]></title>
    <url>%2F2017%2F03%2F23%2Fi022%2F</url>
    <content type="text"><![CDATA[Web AppWeb App 指采用Html5语言写出的App,无需下载安装，可以说是触屏版的网页应用。优点: 开发成本低， 更新快， 更新无需通知用户，不需要手动升级， 能够跨多个平台和终端。 缺点： 临时性的入口 无法获取系统级别的通知，提醒，动效等等 用户留存率低 设计受限制诸多 体验较差 Hybrid App Hybrid APP指的是半原生半Web的混合类App,需要下载，访问的内容是 Web。 Hybrid App 极力去打造类似于Native App 的体验，但仍受限于技术，网速，等等很多因素。尚不完美。 Native AppNative APP 指的是原生程序，一般依托于操作系统，有很强的交互，是一个完整的App，可拓展性强。需要用户下载安装使用。优点： 打造完美的用户体验 性能稳定 操作速度快，上手流畅 访问本地资源（通讯录，相册） 设计出色的动效，转场， 拥有系统级别的贴心通知或提醒 用户留存率高缺点： 分发成本高（不同平台有不同的开发语言和界面适配） 维护成本高（例如一款App已更新至V5版本，但仍有用户在使用V2， V3， V4版本，需要更多的开发人员维护之前的版本） 更新缓慢，根据不同平台，提交–审核–上线 等等不同的流程，需要经过的流程较复杂 个人理解3种App都有各自的优缺点，主要还是看具体业务要求，比如说我们现在要做一个产品，主要展示些产品的特性，功能，用Native APP可能就不是最好的选择，Web App就比较适合。可能在若干年后，随着技术的发展Hybrid APP可能就是最好的选择。总之一句话，适合的才是王道。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[先行者]]></title>
    <url>%2F2017%2F03%2F19%2F%E5%85%88%E8%A1%8C%E8%80%85%2F</url>
    <content type="text"><![CDATA[玉伯技术 聊聊JSONP中的P 用 JavaScript 检测 CPU 占比和内存泄露 关于 Sea.js、开源与前端之路 感悟 前端的归宿与价值 从英语到计算机基础知识 关于 Sea.js、开源与前端之路 观点决定关注点 对企业家最重要的两条规则 Spenser 说49次爱北京 会飞的黄油 来上海绝对不能错过的10家面包店]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JSONP]]></title>
    <url>%2F2017%2F03%2F05%2Fi036%2F</url>
    <content type="text"><![CDATA[JSONP的原理：[json with padding] 引入文件通过回调函数将获取到的数据当成参数传递给回调函数中的变量。 跨域问题： 域顾名思义就是域名，跨域表示一个域名下的文件访问另一个域名下的资源。解决跨域问题的方法[由于AJAX存在跨域限制] 通过JSONP，也就是script标签 通过服务器中转 通过flash,创建一个xml文件 1234567891011function fn(a)&#123; console.log(a.s[0])&#125;window.onload=function ()&#123; var btn=document.getElementById(&quot;btn&quot;); btn.onclick=function ()&#123; var olink=document.createElement(&quot;script&quot;); olink.src=&quot;http://suggestion.baidu.com/su?wd=a&amp;cb=fn&quot;; document.body.appendChild(olink); &#125;&#125; AJAX与JSONP的异同 这2种调用方式在技术上看起来很像，都是请求一个URL,再把返回的数据进行处理，因此也可以这样说，jQuery是把JSONP作为AJAX的一种方式进行了封装。 但本质上而言，2者是不同的东西，AJAX是通过XMLHttpRequest获取非本页面的内容，而JSONP则是通过动态创建script获取服务器返回的数据【js脚本】。 两者的数据格式不一定非得是json格式，可以是任何格式，只不过json格式更为简便明了。 总而言之，jsonp不是ajax的一个特例，哪怕jquery把jsonp封装进ajax，也不能改变这一点！ 参考文章]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue【一】]]></title>
    <url>%2F2017%2F02%2F05%2Fi035%2F</url>
    <content type="text"><![CDATA[诞生背景 由于手机的迅速普及及性能的大幅提升，导致移动端需求的大量增加，产生了一种叫Webapp的东西，即移动端网页应用。 什么是MVVM框架MVVM可以拆分成：View — ViewModel — Model三部分，如图所示：View和Model可以通过ViewModel动态进行数据传输，不再需要手动更改。 Vue的核心通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。由于使用了ES5的Object.defineProperty特性，使得无法兼容IE8及以下版本浏览器。 Vue的数据驱动：数据改变驱动了视图的自动更新，传统的做法你得手动改变DOM来改变视图，vue只需要改变数据，就会自动改变视图，再也不用你去操心DOM的更新了，这就是MVVM思想的实现。 视图组件化：把整一个网页的拆分成一个个区块，每个区块我们可以看作成一个组件。网页由多个组件拼接或者嵌套组成。如图所示： 适用场景 替代jquery频繁操作DOM更新页面 对相同部分进行封装，提升开发效率 一个实例 步骤：new Vue()–&gt;设置数据data–&gt;挂载元素–&gt;成功渲染 123456789101112131415161718&lt;div id=&quot;app&quot;&gt; &lt;card&gt;&lt;/card&gt; &lt;card&gt;&lt;/card&gt; &lt;card&gt;&lt;/card&gt;&lt;/div&gt;&lt;script&gt;Vue.component(&apos;card&apos;,&#123; template:`&lt;div&gt; &lt;img src=&quot;img/pic.png&quot; alt=&quot;&quot;&gt; &lt;h2&gt;这是个标题&lt;/h2&gt; &lt;p&gt;这里是描述&lt;/p&gt; &lt;button&gt;这是个按钮&lt;/button&gt; &lt;/div&gt;`&#125;);new Vue(&#123; el:&quot;#app&quot;&#125;);&lt;/script&gt;]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX的封装]]></title>
    <url>%2F2017%2F01%2F28%2Fi027%2F</url>
    <content type="text"><![CDATA[ajax的封装: 123456789101112131415161718192021222324252627282930313233343536function ajax(method,url,data,success)&#123; var xhr; try&#123; //尝试执行try中的代码，如有错误，执行catch中的代码并返回错误信息 xhr=new XMLHttpRequest(); //throw new Error(&apos;手动报错&apos;); &#125;catch(e)&#123; xhr=new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); //alert(e); &#125; var btn=document.getElementById(&quot;btn&quot;); btn.onclick=function ()&#123; setInterval(function ()&#123; var xhr=new XMLHttpRequest(); if(method == &quot;get&quot; &amp;&amp; data)&#123; url+=&quot;?&quot;+data; &#125; xhr.open(method,url,true); if(method == &quot;get&quot;)&#123; xhr.send(); &#125;else&#123; xhr.setRequestHeader(&apos;content-type&apos;,&apos;application/x-www-form-urlencoded&apos;); xhr.send(data); &#125; xhr.onreadystatechange=function ()&#123; if(xhr.readyState == 4)&#123; if(xhr.status == 200)&#123; success &amp;&amp; success(xhr.responseText) &#125;else&#123; alert(&quot;出错了&quot;+xhr.status); &#125; &#125; &#125;; &#125;,1000) &#125;&#125; 数据:123456789101112&lt;?phpheader(&apos;content-type:text.html;charset:&quot;utf-8&quot;&apos;);error_reporting(0);$news=array( array(&quot;title&quot;=&gt;&quot;中国又一工程惊艳世界:世界最深高铁站&quot;,&quot;date&quot;=&gt;&quot;[2017-7-5]&quot;), array(&quot;title&quot;=&gt;&quot;院士:让中国转基因鲤鱼尽快游向餐桌 &quot;,&quot;date&quot;=&gt;&quot;[2017-7-5]&quot;), array(&quot;title&quot;=&gt;&quot;中戏老师怒怼战狼2:一文不值心理变态&quot;,&quot;date&quot;=&gt;&quot;[2017-7-5]&quot;), array(&quot;title&quot;=&gt;&quot;陕西一区委书记赴宴被富豪打 纪委披露&quot;,&quot;date&quot;=&gt;&quot;[2017-7-5]&quot;), array(&quot;title&quot;=&gt;&quot;2.3公里路司机绕成30公里 滴滴愿赔1千&quot;,&quot;date&quot;=&gt;&quot;[2017-7-5]&quot;));echo json_encode($news);?&gt;]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用Git命令收录]]></title>
    <url>%2F2017%2F01%2F05%2Fi028%2F</url>
    <content type="text"><![CDATA[Git命令速查表 生成SSH 1$ ssh-keygen -t ras -C &quot;email@xxx&quot; 设置用户名 12$ git config --global user.name &quot;webykj&quot;$ git config --global user.email &quot;stormykj@163.com&quot; 初始化当前项目 1$ git init 在该目录下新建一个文件，然后查看，将修改添加到暂存区 12345echo &quot;# test&quot; &gt;&gt; README.mdgit add * //将工作区所有修改添加到暂存区git add . //将工作区所有修改添加到暂存区git add filename //将指定文件添加到暂存区git status //列出变更文件 将暂存区修改添加到本地仓库 1git commit -m &apos;备注信息&apos; 创建仓库，并将上诉改动push到远程 12git remote add origin https://github.com/webykj/test.gitgit push -u origin master 去除push时每次都要输入账号密码 12git remote rm origin //移除git remote add origin git@github.com:gitname/test.git //添加 从远程clone项目 1git clone url 放弃暂存区修改 12345git checkout -- filename //放弃暂存区修改（修改不在）git rm --cached filename //放弃add（修改还在，但产生一条delete记录）git reset HEAD filename //同上（没有delete记录）git stash //暂时放弃未提交的修改git stash pop //恢复 分支操作 1234567891011121314151617/*查看分支*/git branch //所有本地分支git branch -r //所有远程分支git branch -a //所有远程分支和本地分支/*创建分支*/ git branch branchName //留在当前分支git checkout -b branchName //创建并切换分支git branch --set-upstream-to=&lt;remote&gt;/branchName //建立本地分支与远程分支的追踪关系git branch --track branchName [remote branch] //新建一个分支，并与远程建立追踪关系 git checkout branchName //切到指定分支 /*分支合并*/ git pull origin branch //取回远程更新并与本地分支合并 git fetch origin branch //取回远程更新 git merge branch //合并指定分支到当前分支(产生提交记录) git rebase branch //合并指定分支到当前分支(不产生提交记录，比较适合有强迫症的) git cherry-pick commitId //将与commitId对应的提交合进当前分支]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX【一】]]></title>
    <url>%2F2016%2F12%2F26%2Fi024%2F</url>
    <content type="text"><![CDATA[Asynchronous JavaScript and XML（异步JavaScript和XML)，是一种创建交互式网页应用的网页开发技术。 AJAX工作原理： AJAX的工作原理：Ajax的工作原理相当于在用户和服务器之间加了—个中间层(AJAX引擎),使用户操作与服务器响应异步化。并不是所有的用户请求都提交给服务器,像—些数据验证和数据处理等都交给Ajax引擎自己来做,只有确定需要从服务器读取新数据时再由Ajax引擎代为向服务器提交请求。 Ajax其核心有JavaScript、XMLHTTPRequest、DOM对象组成，通过XmlHttpRequest对象来向服务器发异步请求，从服务器获得数据，然后用JavaScript来操作DOM而更新页面。这其中最关键的一步就是从服务器获得请求数据。让我们来了解这几个对象。 AJAX优点： 节省用户操作，提高用户体验，减少数据请求 无刷新更新数据 异步与服务器通信 基于标准被广泛支持 。。。 AJAX缺点： 没有了Back和History功能，即对浏览器机制的破坏 AJAX的安全问题 对搜索引擎支持较弱 。。。 Ajax适用场景 表单验证 快速的用户与用户间的交流响应 对数据进行过滤和操纵相关数据的场景 普通的文本输入提示和自动完成的场景 。。。 Ajax不适用场景 搜索 基本的导航 替换大量的文本 。。。 第一个Ajax应用：12345678910111213141516171819202122232425262728293031323334353637&lt;input type=&quot;button&quot; value=&quot;提交&quot; id=&quot;btn&quot;&gt;&lt;script&gt; window.onload=function ()&#123; //ie兼容问题 new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;) var xhr; //方法一 /*if(window.XMLHttpRequest)&#123; xhr=new XMLHttpRequest(); &#125;else&#123; xhr=new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); &#125;*/ //方法二： try&#123; //尝试执行try中的代码，如有错误，执行catch中的代码并返回错误信息 xhr=new XMLHttpRequest(); //throw new Error(&apos;手动报错&apos;); &#125;catch(e)&#123; xhr=new ActiveXObject(&apos;Microsoft.XMLHTTP&apos;); //alert(e); &#125; var btn=document.getElementById(&quot;btn&quot;); btn.onclick=function ()&#123; var xhr=new XMLHttpRequest(); xhr.open(&apos;get&apos;,&apos;msg/msg.txt&apos;,true); xhr.send(); xhr.onreadystatechange=function ()&#123; if(xhr.readyState ==4)&#123; if(xhr.status ==200)&#123; alert(xhr.responseText); &#125;else&#123; alert(&quot;出错了&quot;+xhr.status); &#125; &#125; &#125; &#125; &#125;&lt;/script&gt;]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《软技能，代码之外的生存指南》]]></title>
    <url>%2F2016%2F12%2F25%2Fb006%2F</url>
    <content type="text"><![CDATA[这本书分为职业，自我营销，学习，生产力，理财，健身，精神7大板块，这里我仅摘录自己比较有感触的，并谈谈自己的理解。 首先说学习 教育就是当一个人把在学校所学全部忘光之后剩下的东西。教育的首要目标，并不在于“知”而在于“行”。 软件开发的世界总是不断变化的，具体到自己从事的Web前端开发来说，变化更是如此。新技术层出不穷，这就需要我们学会如何学习。本书所提到的十步学习法或多或少的为我们提供了一些借鉴。 了解全局 确定范围 定义目标 寻找资源 创建学习计划 筛选资源 开始学习，浅尝辄止 动手操作，边玩边学 全面掌握，学以致用 乐为人师，融会贯通 前6步只需做一次就好，后面的几步则需要反复练习，直到找到适合自己的方法，这就需要我们不断尝试完善，努力提升自己的开发学习效率。 再说理财 金钱只是一种工具。它会带你去任何你想要去的地方，但不会取代你成为司机。 俗话书“你不理财，财不理你”，理财郑重东西，真不是说说就能做好的，需要自己不断摸索，找到适合自己的。比如说我自己，现在也会尝试买一些基金等理财产品。每次可能并不多，贵在坚持，如果自控力不是太好，可以尝试每月定投，强制自己。但我感觉只要开始了，之后看着收益的增加，也就形成了一种习惯，这种习惯，可真不是拿钱就可以买到的。 什么是期权 期权从根本上说就是赋予你在未来某个日期之前以固定价格购买一定数量股票的选择权。 最后说说健身 人的身体就是人的灵魂的最好写照。 健身不仅是保持健康体魄的关键要素之一，也是灵活的、具有创造性的脑力活动的基础。 健康身体的重要性不言而喻。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX中open()方法与表单]]></title>
    <url>%2F2016%2F12%2F03%2Fi025%2F</url>
    <content type="text"><![CDATA[12var xhr=new XMLHttpRequest();xhr.open(&apos;get&apos;,&apos;msg/msg.txt&apos;,true); //打开方式，地址，是否异步 注意： 异步：非阻塞模式，表示前面代码不会影响后面代码的执行。同步：非阻塞模式，表示前面代码会会影响后面代码的执行。在选择同步还是异步的过程中，需要判断前面的代码是否会影响后面的代码，如果会，那么就必须选择同步，否则，便是异步。 表单1234567891011121314151617&lt;form action=&quot;get.php&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;user&quot; value=&quot;john&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;age&quot; value=&quot;20&quot;&gt; &lt;input type=&quot;password&quot; name=&quot;pwd&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt;&lt;/form&gt;&lt;?php header(&apos;content-type:text.html;charset:&quot;utf-8&quot;&apos;); error_reporting(0); /*$user=$_GET[&apos;user&apos;]; $age=$_GET[&apos;age&apos;]; $pwd=$_GET[&apos;pwd&apos;];*/ $user=$_POST[&apos;user&apos;]; $age=$_POST[&apos;age&apos;]; $pwd=$_POST[&apos;pwd&apos;]; echo &quot;&#123;$user&#125;,&#123;$age&#125;,$&#123;pwd&#125;&quot;;?&gt; 区分get与post1234xxx.open(&apos;get&apos;,&apos;get.php?username=&apos;+encodeURL(&apos;张三&apos;)+&apos;&amp;age=30&apos;+new Date().getTime(),true);xxx.open(&apos;post&apos;,&apos;post.php&apos;,true);xxx.setRequestHeader(&apos;content-type&apos;,&apos;application/x-www-form-urlencoded&apos;);xxx.send(&apos;username=zhangsan&apos;&amp;age=22); 缓存问题需要在？后添加一个随记函数或时间戳。 post,数据放在send()方法里，作为参数传递。 编码问题需用encodeURL()解决。 持续更新完善中。。。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 相等性判断]]></title>
    <url>%2F2016%2F11%2F20%2Fi031%2F</url>
    <content type="text"><![CDATA[关于 JS 相等性判断，很容易想到严格相等（===）和非严格相等（==），前者在比较前不会进行隐式转换，即若比较的两个值不是相同的类型，比较结果一定是不等的。而后者在进行比较前可能会根据具体情况进行相应的类型转换然后再按照严格比较规则进行比较。 通常情况下使用严格相等是没有问题的，但存在两个例外。一个是+0和-0的比较，另一个是NaN的比较。 在严格相等中，+0 === -0 返回 true，NaN === NaN 返回 false，这与直观判断是不一致的。为了避免这类特殊情况，可以通过 ES6 新特性 Object.is 来进行判断。代码如下： 123456789101112if (!Object.is) &#123; Object.is = function(x, y) &#123; // SameValue algorithm if (x === y) &#123; // Steps 1-5, 7-10 // Steps 6.b-6.e: +0 != -0 return x !== 0 || 1 / x === 1 / y; &#125; else &#123; // Step 6.a: NaN == NaN return x !== x &amp;&amp; y !== y; &#125; &#125;;&#125; Polyfill 也很容易实现，对于+0和-0比较，首先严格相等，再判断倒数是否不相等即可，因为+0/0结果是Infinity，-0/0结果是-Infinity。而对于NaN比较问题，只需要判断二者分别不等于自身即可。（isNaN仅可判断当前数是否是NaN） 总结： JavaScript 提供三种不同的比较操作符：严格相等、非严格相等、Object.is。 ES2015标准提供以下四种比较操作符：严格相等、非严格相等、零值相等、同值相等。 同值相等参考JavaScript 中相等性判断中 Object.defineProperty 实例，当试图对不可变属性进行修改时可能会发生错误。同值相等由 Object.is 方法提供。 零值相等和同值相等类似，不过会认为 +0 与 -0 相等。 参考： JavaScript 中相等性判断 Object.is 从 V8 的单元测试源码看“同值相等”]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[同源策略与跨域]]></title>
    <url>%2F2016%2F11%2F10%2Fi041%2F</url>
    <content type="text"><![CDATA[同源策略 所谓同源是指2个页面要具有相同的协议，域名，端口，三者缺一不可。 同源策略指的是浏览器对不同源的脚本或文本的访问进行限制，即源a下的js文件无法获取源b下的元素属性。 同源策略限制的是js中XMLHttpRequest请求，以下情况不受同源策略的影响： 页面中的链接，重定向，表单提交 允许跨域资源的嵌入，如果要阻止iframe嵌入我们网站的资源(页面或者js等)，我们可以在web服务器加上一个X-Frame-Options DENY头部来限制。 跨域问题 前提条件是我们在WEB服务器或者服务端脚本中设置ACCESS-CONTROL-ALLOW-ORIGIN头部，如果设置了这些头部并允许某些域名跨域访问，则浏览器就会跳过同源策略的限制返回对应的内容。 AJAX跨域1234567891011121314151617181920212223242526# index.html&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;test cross domain&lt;/title&gt;&lt;script src=&quot;/js/jquery.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;http://www.bar.com/js/test.js&quot;&gt;&lt;/script&gt;&lt;script&gt;$(function()&#123; document.domain = &apos;foo.com&apos;; //1 注释掉则会报错 var ifr = document.getElementById(&quot;testframe&quot;); ifr.onload = function()&#123; var doc = ifr.contentDocument || ifr.contentWindow.document; alert(doc.getElementsByTagName(&quot;h1&quot;)[0].childNodes[0].nodeValue); &#125;&#125;);$.ajax(&quot;http://www.bar.com/js/test.js&quot;); //2 报错&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Test Cross Domain&lt;/h1&gt;&lt;iframe id=&quot;testframe&quot; src=&quot;http://foo.com/test.html&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; JSONP跨域实现原理 与AJAX没多大关系，通过动态插入script标签来实现跨域资源访问。 123456789101112131415161718# jsonp.html&lt;script type=&quot;text/javascript&quot;&gt; function callback(data) &#123; alert(data.message); &#125; function addScriptTag(src)&#123; var script = document.createElement(&apos;script&apos;); script.src = src; document.body.appendChild(script); &#125; window.onload = function()&#123; addScriptTag(&quot;http://www.foo.com/js/outer.js&quot;); &#125;&lt;/script&gt;# outer.jscallback(&#123;message:&quot;success&quot;&#125;); 通过动态创建script标签加载outer.js文件，然后outer.js文件返回的内容正好是一个函数调用，如此，实现了数据传递和回调过程。当然，实际的jsonp接口中，会传一个函数名过去，然后返回的数据中回调函数名就是传的函数名，回调函数的参数则是封装的json格式。 参考文章]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[GET与POST区别]]></title>
    <url>%2F2016%2F11%2F10%2Fi029%2F</url>
    <content type="text"><![CDATA[以前我们是可能是这样认为的： GET使用URL或Cookie传参。而POST将数据放在BODY中。 GET的URL会有长度上的限制，则POST的数据则可以非常大。 POST比GET安全，因为数据在地址栏上不可见。 可是，经过查证，They’re wrong，我也感觉不可思议，以前我就这样认为啊！ GET和POST与数据如何传递没有关系 GET和POST是由HTTP协议定义的。在HTTP协议中，Method和Data（URL， Body， Header）是正交的两个概念，也就是说，使用哪个Method与应用层的数据如何传输是没有相互关系的。 HTTP没有要求，如果Method是POST数据就要放在BODY中。也没有要求，如果Method是GET，数据（参数）就一定要放在URL中而不能放在BODY中。 HTTP协议对GET和POST都没有对长度的限制 HTTP协议明确地指出了，HTTP头和Body都没有长度的要求。而对于URL长度上的限制，有两方面的原因造成： 浏览器。据说早期的浏览器会对URL长度做限制。据说IE对URL长度会限制在2048个字符内（流传很广，而且无数同事都表示认同）。但我自己试了一下，我构造了90K的URL通过IE9访问live.com，是正常的。网上的东西，哪怕是Wikipedia上的，也不能信。 服务器。URL长了，对服务器处理也是一种负担。原本一个会话就没有多少数据，现在如果有人恶意地构造几个几M大小的URL，并不停地访问你的服务器。服务器的最大并发数显然会下降。另一种攻击方式是，把告诉服务器Content-Length是一个很大的数，然后只给服务器发一点儿数据，嘿嘿，服务器你就傻等着去吧。哪怕你有超时设置，这种故意的次次访问超时也能让服务器吃不了兜着走。有鉴于此，多数服务器出于安全啦、稳定啦方面的考虑，会给URL长度加限制。但是这个限制是针对所有HTTP请求的，与GET、POST没有关系。 安全不安全和GET、POST可能并不是我们认为的那种关系。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6增加的扩展]]></title>
    <url>%2F2016%2F11%2F05%2Fi033%2F</url>
    <content type="text"><![CDATA[ECMAScript是什么 JavaScript是JavaScript的重要组成部分。简单一句话，ESMAScript是JavaScript的语法规范。与DOM,BOM成为JavaScript的3驾马车。不仅如此，它还定义了语法，类型，原型和继承及内置对象和函数标准库。 ECMAScript 和 JavaScript 的关系 ECMAScript是JavaScript的基础标准部分，前者是后者的规格，后者是前者的一种实现。 ES6 与 ECMAScript 2015 的关系 ES6是一个泛指，是5.1版以后的 JavaScript 的下一代标准，涵盖了ES2015、ES2016、ES2017等.而ES2015 则是正式名称，特指该年发布的正式版本的语言标准。 let命令123&#123;var a=10; let b=1;&#125;a //10b // ReferenceError: b is not defined. 表明let只在它所在的代码块起作用 123456789101112131415161718192021222324var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10//i在全局范围内部都有效var b=[];for(let i=0;i&lt;10;i++)&#123; b[i] = function () &#123; console.log(i) &#125;&#125;b[6](); // 6//i只在本轮循环中有效for (let i = 0; i &lt; 3; i++) &#123; let i = &apos;abc&apos;; console.log(i);&#125;// abc// abc// abc//输出了3次abc。表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 let不存在变量提升var命令的变量可在声明前使用，值为undefinedlet命令的变量必须先声明在使用。 123456console.log(foo);var foo=2;//undefinedconsole.log(bar);let bar=2;//ReferenceError: bar is not defined 暂时性死区 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 只要块级作用域中存在let命令，所声明的变量就绑定之歌区域，不再受外部影响 123456789101112131415//使用let命令声明变量之前，该变量不可用if (true) &#123; // TDZ开始 tmp = &apos;abc&apos;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125;// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 小结 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。 暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 用let声明的变量只在块级作用域起作用，适用于for循坏。在同一个代码块中，不可声明相同的变量，不可重复声明函数内的参数。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 123456789101112131415161718// 报错function () &#123; let a = 10; var a = 1;&#125;// 报错function () &#123; let a = 10; let a = 1;&#125;function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 块级作用域存在原因一：内层变量可能会覆盖外层变量。 123456789var tmp=new Date();function f()&#123; console.log(tmp); if(false)&#123; var tmp=&quot;hello wrold!&quot;; &#125;&#125;f();//由于变量提升，导致内层变量覆盖外层变量，使得输出结果为undefined 存在原因二：用来计数的循环变量泄露为全局变量。123456var s = &apos;hello&apos;;for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5//变量i用于控制循环，但循环结束后，并没有消失，而成为了全局变量。 ES6块级作用域12345678function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125;//表示外层代码块不受内层块级代码快的影响，若使用var声明，结果为10 const 命令 const声明一个只读的常量。一旦声明，常量的值就不能改变。要注意声明引用类型的常量时，是传址赋值1234const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 小结： 对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 const声明的常量，也与let一样不可重复声明。 本质： const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 顶层对象的属性 顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。 var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性,换言之，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 123456var a = 1;window.a // 1let b = 1;window.b // undefined//以上可看出全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 不断加深理解并加以完善。。。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我说，你听]]></title>
    <url>%2F2016%2F10%2F29%2F%E4%B8%80%E4%BB%B6%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[姐，我想对你说。。。 一件事，每当夜深人静的时候，自己脑海中总会莫名其妙的想起往事。犹记得，在我上小学的时候，因为几块钱和你吵闹。最后，在我的哭闹下，你还给了我。现在想来，竟是如此可笑。我想，若是现在，对于钱这种东西，在亲情面前，我将它当成纸一般对待，这里的亲情仅限咋们这一家人，爸妈一辈子吵吵闹闹，最后因为咋们几个孩子，常以冷战收官。这背后，十有八九都是因为对老人的问题，我相信咋妈不是那种无理取闹之人，老爸有时过于敏感，可能有时会因此丧失理性。 不过，我相信，在我们几个孩子之间，绝对不会发生类似事情。咱爸有个不称职的哥哥，但我绝不会有不称职的姐姐。这里，我们不去追究谁对谁错，那并不能解决问题。不知咋妈是否给你说过，在去年1.12号，咱爸妈买了1.2万保险，当时咋妈意思是我6000，你和2姐6000，这也是我的意思。我希望最迟后年这份支出由我们几个承担，你觉得呢？ 通过你和二姐结婚，我也看明白了好多事情，比如，那些所谓的亲戚其实就是个笑话，可能我这样讲过于极端，但事实就是这样。咱爸把亲情看的重，只要亲戚有事便会主动跑过去帮忙，并不会考虑是否有必要。可能有些事你都不知道，这里，我也不想过多说什么。我特别喜欢《赚未来十年的钱》中的一句话“人有时候只能以垃圾来形容”，这本书，每当自己迷路的时候，都会看看，写的很现实很纯粹，让你无力反驳。 我有这样一个不成熟的想法，就是2018年底带爸妈来北京过年，之后每年都带爸妈去不同地方旅游，这是一定要做的，至于老爸说的出国，也会一一实现，我相信，我有这样的实力。 至于你说的想自己开个培训机构，我全力支持，比如说，为你搭建个网站，微信开发交给我就好。我相信你的选择，我哥现在从事类似工作就已经说明了一切，虽然很累，但一定要尝试，就像我对自己的要求，30岁要为自己打工，即使没有，也要在路上。 对于结婚这件事，我不想过早结婚，原因千千万，这里主要说几点比较自认为比较重要的。没有事业，一切都是扯淡，我关注的公众号告诉我30岁结婚才是适龄，并不是找不到合适的，只是优先权靠后。用世俗的眼光来看，这孩子可能找不到对象，爸妈得承受世俗压力，说自己孩子怎么怎么样，但我真的不在乎这些，旁人都希望自己过得比他人好，考虑的爸妈的感受，索性就25左右在结婚吧！这一点，我对自己还是比较有信心的。暑假回去，老爸不止一次的跟我说，想把房子卖了置换成单元楼好让爷爷来住，我想，这种想法更多是出于内心的一种自责吧，觉得不能为父亲提供优质的生活，我相信，孝顺，咱爸做到是很棒的。但对于经济这一块，老爸由于养3个孩子，做事总是前怕虎后怕狼，为此，错过了好多机会，这一点，本身并没有什么。这也算是一个不想早结婚的理由吧！我现在，由于老爸给提供了一定基础，可以承担较大风险，可以好好发展经济。可能这就是所谓的阶级流动吧！ 再说理财这件事，其实我感觉咱爸在他们那个年龄段里，收入还是不错的，但就败在对钱的态度上，不愿承担风险，只求稳定，但把钱存在银行只能被人当韭菜割，没办法，这种事情真不是说说就能改变的。 最后，祝老姐生日快乐，我也相信，很快我会开启人生新篇章。 2017-09-18]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery源码【一】]]></title>
    <url>%2F2016%2F10%2F28%2Fjq%2F</url>
    <content type="text"><![CDATA[jQuery的出现是为了解决跨浏览器之间的兼容问题，使得DOM操作趋于统一。由于它强大的封住，深受开发人员的喜欢。不仅如此，它还具有以下优势。 体积小，使用灵巧 丰富的DOM选择器 跨浏览器、链式语法 强大的事件、样式支持 强大的AJAX功能 丰富的插件 ##jQuery选择器 123456789$(&apos;div&gt;p&apos;); //可以是字符串$($(&apos;div&gt;p&apos;)); //可以是jQuery对象$(); //document简写$(function ()&#123; //与jQuery.ready一样&#125;);$([]); //参数可以是数组$(&#123;&#125;); //参数可以是对象$(1); //参数可以是数字 执行时机DOM文档加载是按训执行的，这与浏览器的渲染方式有关系，一般浏览器的渲染顺序是按照以下几个步骤执行的。 解析HTML结构 加载外部脚本和样式表文件 解析并执行脚本代码 构造HTML DOM模型 加载图片等外部文件 页面加载完毕 load事件必须等到网页所有内容全部加载完毕后才会执行。若一个页面包含许多多媒体文件，就会出现以下情况；网页文档已呈现出来，但网页数据还没有加载完成，导致load事件不能被即时触发。 而jQuery的ready事件是在DOM结构绘制完毕后就执行，也就说它在外部文件加载之前就已经执行了，这样就能确保网页文档的呈现于脚本的初始化设置保持同步。 总之，ready事件先于load事件被激活，若网页中没有加载外部文件，则它们的响应事件基本一样。 要做什么先看需要做什么属性操作如attribute、class和style都可看做属性操作，jQuery也扩展了一些属性，如缓存数据等。 元素操作如元素的创建、添加、补加、移动、复制和删除等。对于添加操作又可分为追加、插入、前插、后插、内部前插、内部后插等。 内容操作在JavsScript中提供了innerHTML属性操作的HTML内容，也可以使用childNodes操作元素包含的子节点内容，或使用value获取元素的值等。但是，jQuery把这些方法属性分为不同的方法，并形成方便内容操作的方法。 样式操作CSS是DOM中最重要的模块，它包括元素的height、width、innerHTML、innerWidth、position、offset和display等，还包括由这些方法演变出来的各种动画方法等。 动画时CSS的高级形态，无论什么动画，都是基于时间的长短映射到元素的CSS的变化属性值。一般都是通过setIntercal()方法间隔设置CSS样式，从而形成动画。 事件操作Event也是DOM的重要模块，包括addEvent、removeEvent和domready等。 jQuery做到了write less do more，以后，妈妈再也不用担心我的开发了。。。 好了，就先这样吧。正所谓饭要一口一口吃，技术要一点一点学。。。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AJAX总结]]></title>
    <url>%2F2016%2F10%2F20%2Fi020%2F</url>
    <content type="text"><![CDATA[什么是AJAX AJAX = 异步 JavaScript 和 XML，是一种用于创建快速动态网页的技术，可实现局部刷新。主要应用于表单验证、按需获取数据、自动刷新页面。 标准XmlHttpRequest的属性 onreadystatechange: 每个状态改变时都会触发这个事件处理器，通常指向一个JavaScript函数; readyState: 请求的状态。有5个可取值：0=未初始化，1=正在加载，2=已加载，3=交互中，4=完成; responseText: 服务器的响应，表示为一个串; responseXML: 服务器的响应，表示为XML。这个对象可以解析为一个DOM对象; status: 服务器的HTTP状态码（200对应OK，404表示Not Found(未找到)，等等); statusText: HTTP状态码的相应文本(OK或Not Found等等). XmlHttpRequest的方法 abort(): 停止当前请求; getAllResponseHeaders(): 把HTTP请求的所有响应作为键/值对返回; getResponseHeader(“header”): 返回指定首部的串值; open(method, url): 建立对服务器的调用。method参数可以是GET, POST或PUT。 url参数可以是相对的或者绝对的URL。该方法还包括3个可选参数; send(content): 向服务器发送请求; setRequestHeader(header, value): 把指定首部设置为所提供的值。在设置任何首部之前必须先调用open(). AJAX常用方法 get() post() load() 只能用于静态html页面 json jsonp() 最底层： ajax第二层： load/get/post 高频使用第三层： json/jsonp jQuery中的AJAX123456789101112131415161718192021222324252627$.ajax(&#123; url:&apos;/comm/test1.php&apos;, type:&apos;POST&apos;, //GET async:true, //或false,是否异步 data:&#123; name:&apos;yang&apos;,age:25 &#125;, timeout:5000, //超时时间 dataType:&apos;json&apos;, //返回的数据格式：json/xml/html/script/jsonp/text beforeSend:function(xhr)&#123; console.log(xhr) console.log(&apos;发送前&apos;) &#125;, success:function(data,textStatus,jqXHR)&#123; console.log(data) console.log(textStatus) console.log(jqXHR) &#125;, error:function(xhr,textStatus)&#123; console.log(&apos;错误&apos;) console.log(xhr) console.log(textStatus) &#125;, complete:function()&#123; console.log(&apos;结束&apos;) &#125;&#125;) 常用参数123456789var configObj = &#123; method //数据的提交方式：get和post url //数据的提交路劲 async //是否支持异步刷新，默认是true data //需要提交的数据 dataType //服务器返回数据的类型，例如xml,String,Json等 success //请求成功后的回调函数 error //请求失败后的回调函数 &#125; JavaScript中的AJAX123456789101112131415161718192021$(&apos;#send&apos;).click(function()&#123; //请求的5个阶段，对应readyState的值 //0: 未初始化，send方法未调用； //1: 正在发送请求，send方法已调用； //2: 请求发送完毕，send方法执行完毕； //3: 正在解析响应内容； //4: 响应内容解析完毕； var data = &apos;name=yang&apos;; var xhr = new XMLHttpRequest(); //创建一个ajax对象 xhr.onreadystatechange = function(event)&#123; //对ajax对象进行监听 if(xhr.readyState == 4)&#123; //4表示解析完毕 if(xhr.status == 200)&#123; //200为正常返回 console.log(xhr) &#125; &#125; &#125;; xhr.open(&apos;POST&apos;,&apos;url&apos;,true); //建立连接，参数一：发送方式，二：请求地址，三：是否异步，true为异步 xhr.setRequestHeader(&apos;Content-type&apos;,&apos;application/x-www-form-urlencoded&apos;); //可有可无 xhr.send(data); //发送&#125;); AJAX参考文章 AJAX之XMLHttpRequest方法和属性详解]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>AJAX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript核心及实践》]]></title>
    <url>%2F2016%2F10%2F18%2Fb004%2F</url>
    <content type="text"><![CDATA[JavaScript语言特性 JavaScript是一门动态的，弱类型，基于原型的动态语言。用一句话“一切皆对象”描述在好不过了。 动态性指要为属性赋值时，不必先创建一个字段，只需在使用时赋值即可。弱类型指数据类型无需声明时指定，解释器会根据上下文进行实例化。 对象与JSON JSON是JavaScript中对象的字面量，是对象的表示方法，通过使用JSON，可以减少中间变量，使代码更加清晰直观。使用JSON，可以动态创建对象，而不必通过类来实例化，提高了编码效率。 原型对象与原型链 原型是JavaScript特有的概念，通过原型，可以实现继承，从而体现对象的层次关系。由于本身基于原型，使得每个对象都有一个prototype值，而这个prototype本身就是就是一个对象，因此本身就有自己的原型，这样就构成了一个链结构。 当访问一个属性时，解析器需要从下向上遍历这个链结构，直到该属性，若此对象没有该属性，则返回undefined。比如下面的例子： 1234567891011121314151617181920//声明一个对象basefunction Base(name)&#123; this.name=name; this.getName=function ()&#123; return this.name; &#125;&#125;//声明一个childfunction Child(id)&#123; this.id=id; this.getId=function ()&#123; return this.id; &#125;&#125;//将child原型指向base对象Child.prototype=new Base(&quot;base&quot;);//实例化child对象var c=new Child(&quot;child&quot;);console.log(c.getId());console.log(c.getName()); //通过原型继承到getName方法 继承与重载123456789101112function person(name,age)&#123; this.name=name; this.age=age; this.getName=function ()&#123; return this.name; &#125; this.getAge=function ()&#123; return this.age; &#125;&#125;var Tom=new person(&quot;Tom&quot;,22);var Alice=new person(&quot;Alice&quot;,20); 通过原型链，可以实现继承/重载等面向JavaScript代码，当然这个机制并非基于类，而是基于原型。 this指针 在JavaScript中，this表示当前上下文，是对调用者的引用。这里要注意，this值并非函数如何声明而确定，而是在调用时确定。 使用对象1234567891011121314151617181920212223242526272829function address(street,num)&#123; this.street=street || &quot;This is a road&quot;; this.num=num || 22; this.toString=function ()&#123; return this.street+this.num; &#125;&#125;function person(name,age,addr)&#123; this.name=name || &quot;unknown&quot;; this.age=age; this.addr=addr || new address(null,null); this.getname=function ()&#123; return this.name; &#125; this.getage=function ()&#123; return this.age; &#125; this.getaddr=function ()&#123; return this.addr.toString(); &#125;&#125;var John=new person(&apos;John&apos;,22,new address(&quot;road&quot;,&quot;111&quot;));var Alice=new person(&apos;Alice&apos;,12);console.log(John.getname());console.log(John.getage());console.log(John.getaddr());console.log(Alice.getname());console.log(Alice.getage());console.log(Alice.getaddr()); JSON及其使用12345678910111213141516171819202122232425//对象表示法var obj=&#123; name:&quot;张三&quot;, age:&quot;22&quot;, birthday: new Date(1999,9,9), addr:&#123; street:&quot;road&quot;, num:222 &#125;&#125;//多个返回值function position(left,top)&#123; this.left=left; this.top=top; return &#123;x:this.left,y:this.top&#125;&#125;var pos=position(3,4);//遍历js对象var style=&#123; border:&quot;1px solid red&quot;, color: &quot;orange&quot;&#125;for(var i in style)&#123; $(&apos;ele&apos;).css(i,style[i])&#125; 未完待续。。。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vh与vw知多少]]></title>
    <url>%2F2016%2F10%2F08%2Fi019%2F</url>
    <content type="text"><![CDATA[都知道响应式布局需要通过rem进行适配，但还需要以下一段js代码动态计算元素大小，但通过vh,vw就可直接通过css直接控制。 1234567891011(function (doc, win) &#123; let docEl = doc.documentElement let resizeEvt = &apos;orientationchange&apos; in window ? &apos;orientationchange&apos; : &apos;resize&apos; let recalc = function () &#123; var clientWidth = docEl.clientWidth if (!clientWidth) return docEl.style.fontSize = 14 * (clientWidth / 320) + &apos;px&apos;; &#125; if (!doc.addEventListener) return win.addEventListener(resizeEvt, recalc, false) doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false) 什么是视口在客户端，视口指浏览器的可视区域；在移动端，涉及3个视口：Layout Viewport（布局视口），Visual Viewport（视觉视口），Ideal Viewport（理想视口），而这里所说的视口是布局视口。 vh/vw与%区别 最优做法——vw和rem配合使用 12345678910111213141516171819202122// rem 单位换算：定为 75px 只是方便运算，750px-75px、640-64px、1080px-108px，如此类推$vm_fontsize: 75; // iPhone 6尺寸的根元素大小基准值@function rem($px) &#123; @return ($px / $vm_fontsize ) * 1rem;&#125;// 根元素大小使用 vw 单位$vm_design: 750;html &#123; font-size: ($vm_fontsize / ($vm_design / 2)) * 100vw; // 同时，通过Media Queries 限制根元素最大最小值 @media screen and (max-width: 320px) &#123; font-size: 64px; &#125; @media screen and (min-width: 540px) &#123; font-size: 108px; &#125;&#125;// body 也增加最大最小宽度限制，避免默认100%宽度的 block 元素跟随 body 而过大过小body &#123; max-width: 540px; min-width: 320px;&#125;]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[张姓菇凉]]></title>
    <url>%2F2016%2F10%2F07%2F%E8%8F%87%E5%87%89%2F</url>
    <content type="text"><![CDATA[张菇凉，做我女票吧。哈哈，愚人节快乐。但愿不要雷到你，看出我无奈脸了吗？继续往下看。。。 Hi，这位同学，还记得我吗？从17 10 06到今天有一段日子了。这期间，从更开始彼此眼神的交流，哈哈，有点自恋了，到后来加你微信，再到偶尔的点赞评论，有时，你会回复我，有时也会保持沉默，但这不重要。重要的是我可以进入你的生活，我不奢望得到你的青睐，只希望你足够好。这对我来说就足够了。 听你说要考研，我也不能帮助你什么，我就是个学渣，啥也不懂。但有个问题希望你能认真考虑下。1。考研是不是就意味着可以找到一份自己比较喜欢的工作。用读研的几年时间换一份可能会比较好的工作，价值在那里？中国一年有900多万大学生，毕业即失业对你来说不存在，这点，我始终坚信。看的出来，你很喜欢自己选的专业。既然喜欢，那就一直追下去。 我不知道我这个问题能不能对你有所帮助，但还是希望你能好好想想，每个人都有自己选择的权利，你的选择，我支持。希望你能明白我的意思。 这里，说下我大姐的经历，我大姐大学在一所普通二本院校，学的英语专业《专8哦》，考西安外国语的研究生，但结果以失败告终。曾经，她坚信一定要考研，但最终并不是这样。可能，也想开了，我希望你能明白一点，能力最重要，社会本身就是最好的大学。我个人感觉大姐现在生活的挺好的。再给你说个小秘密，我大姐的另一半是她的初恋，这点，是我很佩服的。 最后，撒句鸡汤 ，张菇凉， 你若安好，便是晴天。 其实，你可以存下我手机15901416092，始终为你开机。希望可以尽自己的力量帮到你。如果，你不介意的话，也可以把你的发我。哈哈，发现我好XXX。当然，如果能发我些生活照，我还你一个惊喜。 张菇凉，你真的很迷人。 写于10.12晚]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[若深情无法对等，那就让我做那个爱得更多的人。]]></title>
    <url>%2F2016%2F10%2F06%2F%E6%B7%B1%E6%83%85%2F</url>
    <content type="text"><![CDATA[不要做一个吞吞吐吐的人，在这场互动中，你如果没有付出，那些怦然心动，两情相悦，时时刻刻不知如何是好的感觉，你根本无从体味，又怎会领略爱情的种种美好？亲爱的，如果遇见了想爱的人，用力爱一回吧，因为，一辈子这样的遇见并不多。 哥哥对小妹的唠叨，唉，怎么能是小妹呢？小姐姐岂不更贴切。 一个不分东西南北的哥哥想对你说，你不会介意我这样自诩吧！未来我们可能存在的关系，过客，从此再无交集、好朋友、恋人、甚至xx ，我想过所有的结果，但这只是想想！坦率说，我挺喜欢你的，说不出为什么，是种感觉，感觉和你在同一频道，看过一篇文章，大致说喜欢一个人就去追，因为一辈子这样的遇见不多。事实上，还真不多，反正我之前还没遇到过，默默的安慰安慰我的小心脏3分钟。我不相信什么所谓的一见钟情，但有时候，事情并不是以自己的意愿发生。现在，我也不想过分的奢望我们可以怎么怎么样，只希望尽自己的努力可以对你有所帮助，这就够了。毕竟自己的段位自己还是清楚的。张菇凉，你真的很迷人。 WOW，算是表白吗？我不认为是，你可以尽情追逐自己内心的真实想法，毕竟每个人都有选择的权利。喜欢你，义无反顾的喜欢。我不懂什么是爱，也不想懂，我不想以世俗的眼光看待这个问题。喜欢是种感觉，我相信我们的灵魂在同一高度。我爱你，你随意。 有时候，我在想，我这么自私，会不会让你有心理压力，有时甚至想你会不会把我拉黑，还是那句话，我支持你的任何选择。我不知道我们之间最终会是怎样的结果，但那不重要。茫茫人海，遇见本身就是莫大的缘分。 我的要求不高，做99年的朋友就够了。若深情无法对等，那就让我做那个爱得更多的人。我要是猜的没错的话，你应该没男朋友吧！看我的直觉准不准，傲慢。哈哈哈。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[你说的话，温柔了整个世界]]></title>
    <url>%2F2016%2F10%2F06%2F%E4%BD%A0%E8%AF%B4%E7%9A%84%E8%AF%9D%2F</url>
    <content type="text"><![CDATA[先引用一下百度的求职宣传： 一张网页，要经历怎样的过程，才能抵达用户面前？ 一位新人，要经历怎样的成长，才能站在技术之巅？ 探寻这里的秘密； 体验这里的挑战； 成为这里的主人； 加入百度，加入网页搜索，你，可以影响世界。 嗯，对，很温柔。而今天，我要说的是一位张菇凉【一位很很很迷人的姑娘】。虽然我们之间只有一面之缘，但通过为数不多的聊天，我能感受到我和她之间是处在同一频道的。啊，自恋了。自古以来，漂亮的姑娘不乏追求者，尤其是漂亮又有气质的张菇凉。而且还是由内到外的，没有浮夸。 如果我说不喜欢，你会信吗？反正，我不信。我对美的定义是自信的女孩最漂亮。听她说要考研，那意味着我至少有4年的时间可以争取。努力吧，少年！说不定她就是你未来孩子的妈。 世间唯有梦想和好姑娘不可辜负。张菇凉，当你的追求者，默默的关注着你，挺好。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[语录]]></title>
    <url>%2F2016%2F10%2F01%2F%E8%AF%AD%E5%BD%95%2F</url>
    <content type="text"><![CDATA[经典之所以经典那是因为我认可，哈哈，如果我不认可，那么它只是经典。 如果说学javascript就像学数学，那么学html/css则如同学语文。 一枚GOSPA的前端探索者。GOSPA[目标，目的，策略，计划，行动]。 行动重于计划。 最重要的能力是解决问题能力，学习能力是为了更好的解决问题。 成长，是一个雕琢自己的过程。无论是“雕”还是“琢”，都是得用刀的，想想都疼。 愿得我心如明月,独映寒夜迷途人。我为自己加油。 思想引领行动，行动导致习惯，习惯产生性格，性格决定命运。 第一个五年是作业，第二个五年是管理，第三个五年是经营。 自由是独立，不依附，不恐惧。 我们生儿不同，也必定与众不同。 要么庸俗，要么孤独。 人要有志，也要有识，更要有恒。 浮躁是源自内心的一种不安全感。 圣经不是用来读的，而是用来解释的。 一个人的价值取决于你所提供服务的能力或激励他人提供服务的能力。 所有成就、所有辛劳而获的财富，都源于一个想法。 当一个人真心要做某事时，一定会流露出这种思想来。 人性的一个主要弱点就是经常说“不可能”。另一个弱点就是习惯用自己的印象和观念去评价其他人、其他事。 成功只会降临到那些具有成功思想的人身上；失败则钟情于那些听任自己拥有失败思想却无动于衷的人身上。 一切成就的起点都是欲望，一定要将这句话牢记于心。 信念是一种心态，源于自我暗示。 没有被现实洗礼过的，不是真正的理想主义者。 你了解的越多，你就会越发现自己的无知；你经历的越多，就越会发现自己的渺小。 机会成本是指为了得到某种东西而所要放弃另一些东西的最大价值。 一代好母亲，三代好家庭 世间唯有梦想和好姑娘不可辜负。 世间所有的爱，都指向团聚；唯有父母的爱，指向别离… 幸福，不是拿到世界上最好的东西，而是，珍惜生命中的所有。 格局决定结局。 眼睛，是一个人最迷人的地方。 笑的纯粹，哭的狼狈。 什么是鸡汤文，按照我的理解，对自己有帮助的就不是其他都是。]]></content>
      <categories>
        <category>about</category>
      </categories>
      <tags>
        <tag>about</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用js代码片段【一】]]></title>
    <url>%2F2016%2F09%2F28%2Fi017%2F</url>
    <content type="text"><![CDATA[表单验证获取单选值1234567891011function getSex()&#123; var value=&quot;&quot;; var radio=document.getElementsByName(&quot;gender&quot;); for(var i=0;i&lt;radio.length;i++)&#123; if(radio[i].checked==true)&#123; value=radio[i].value; break; &#125; &#125; alert(value);&#125; 过滤数字,自符1234567891011121314151617window.onload=function ()&#123; var id=document.getElementById(&apos;id&apos;); var clearNumber=function (tThis)&#123; var _v=tThis.value; tThis.value=_v.replace(/\D/g,&quot;&quot;); //过滤数字 tThis.value=_v.replace(/[^\u4e00-\u9fa5]/g,&quot;&quot;); //过滤中文 &#125; txt.onblur = function()&#123; clearNumber(this); &#125; txt.onfocus = function()&#123; clearNumber(this); &#125; txt.onkeyup = function()&#123; clearNumber(this); &#125;&#125; 限制用户输入的字符数12345678910111213141516171819window.onload=function ()&#123; var id=document.getElementById(&quot;id&quot;); clearmaxlength=function (tThis)&#123; var _v=tThis.value, _vLen=_v.length, dataLen=tThis.getAttribute(&apos;data-length&apos;), subLen=dataLen; if(_vLen&gt;dataLen) tThis.value=_v.substr(0,subLen); &#125; txt.onblur = function()&#123; clearmaxlength(this); &#125; txt.onfocus = function()&#123; clearmaxlength(this); &#125; txt.onkeyup = function()&#123; clearmaxlength(this); &#125;&#125; 回车提交12345678910window.onload=function ()&#123; var txt=document.getElementById(&quot;txt&quot;); txt.onkeyup=function (e)&#123; e= e || window.event; var keycode=e.keyCode || e.which || e.charCode; if(keycode===13)&#123; alert(&quot;回车提交成功！&quot;) &#125; &#125;&#125; 关键字过滤1234567891011121314window.onload=function ()&#123; var txtfilter=document.getElementById(&quot;id&quot;); txtfilter.onclick=function ()&#123; words=[ &quot;JavaScript&quot;, &quot;美女&quot;, /[外]&#123;1&#125;.&#123;0,3&#125;[挂]&#123;1&#125;/ ], txtLen=words.length; for(var i=0;i&lt;txtLen;i++)&#123; txtfilter.value=txtfilter.value.replace(words[i],&quot;***&quot;); &#125; &#125;&#125; 未完待续。。。 当然，你也可以查看这里。 点击查看更多]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中的面向对象]]></title>
    <url>%2F2016%2F09%2F20%2Fphp%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[面向对象：类：具有相同属性和行为(方法)的一类事物集合，在类里面只能放方法和属性。 对象：类中某个具体的个体，面向对象的三大特点：封装、继承、多态。 this的总结 $this 为当前类。Java 和 C#中，使用“this.成员名”来访问成员，这点 PHP 是大不一样的。 注意是“$this-&gt;name”而不是“$this-&gt;$name”。 也可以使用“$this-&gt;成员函数名”来访问当前类中的成员函数。 $this 关键字是用来访问当前对象中的属性和方法的，仅能在当前对象中使用。 构造方法(魔术方法)12345678910111213141516171819202122class peoples&#123; //属性 public $name; //姓名 访问修饰符(public：公共的) public $height; //身高 访问修饰符(public：公共的) private $age ; //年龄 访问修饰符(private：私有的) //构造方法(魔术方法):初始化时使用 //注意：construct在类实例化时自动被执行 function __construct($n,$h,$a)&#123; echo &apos;hello...&apos;; $this-&gt;name=$n; $this-&gt;height=$h; $this-&gt;age=$a; &#125;//析构方法(魔术方法):通常用来回收资源，释放内存。 //注意：在类使用完成后自动被执行 function __destruct()&#123; echo &apos;hello php ...&apos;; &#125;&#125;$xiaoli=new peoples(&apos;晓丽&apos;, 390, 89);$xiaoli-&gt;work();$xiaoli-&gt;play(); 注意：私有的属性和方法不能被继承，也不能在类的外面被直接使用 类的继承方法重构：12345678910111213141516&lt;?phpclass Animal &#123;public function cry($a) &#123;echo ‘动物正在叫…’;&#125;&#125;class Cat extends Animal &#123;//下面的方法重载时访问范围不正确protected function cry($x) &#123;echo ‘小猫在咪咪叫…&lt;br&gt;’;Animal::cry();&#125;&#125;$cat1 = new Cat();$cat1-&gt;cry();?&gt; 注意: 私有的属性和方法不能被继承，也不能在类的外面被直接使用。 方法现方法重载，重构(当父类中的方法不能满足子类的需求时要重构方法)。 要实则要求子类的那个方法名称、参数列表个数与父类一样，但参数名称可以不一样。 在实现方法重载时访问修饰符可以不一样，但必须满足：子类的访问范围&gt;=父类的访问范围]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面试，你必须做的]]></title>
    <url>%2F2016%2F09%2F17%2F%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[观念的改变为什么先说观念的改变呢。我个人认为对于求职者，观念很重要。要明白一份工作是选择是双向的。但看过太多的求职者在应聘职位时地位总是处于被动地位。尤其是刚毕业的学生。总之，记住以下几点： 自信但不自负。 早做准备，机会是留给有准备的人的。 一份工作嘛，尽力就好；明白被拒绝是正常的。 把自己当做公司思考，一个人就是一个公司 面试基本流程 自我介绍【展现自己的优势】 项目经历 技术问题 自己有何问题 面试前 人脉的积累【六度分割现象】狠重要。 简历的准备，比如star法则。 模拟面试中可能遇到的问题。 面试时 展现出你的热情。 展现出自己解决问题的能力。 对公司产品的理解 给面试官留下深刻印象。 技术HTML篇 行元素，块元素，空元素？ 页面导入样式时，使用link和@import有什么区别？ title与h1的区别、b与strong的区别、i与em的区别？ Doctype作用？标准模式与兼容模式各有什么区别? HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ 网页验证码是干嘛的，是为了解决什么安全问题？ html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ 谈谈你对HTML语义化的理解？ 谈谈你对渐进增强，优雅降级的理解？ HTML5离线存储怎么使用，能不能解释下原理？ 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ CSS篇 介绍下CSS盒模型。 CSS选择器，哪些属性可继承？ CSS优先级如何计算？ CSS3新增伪类，新特性？ 如何水平垂直居中一个div？ display有哪些值，并说出它们的作用。？ position的值relative和absolute定位原点是？ 解释下CSS3弹性盒模型及适用场景？ CSS创建一个三角形原理？ 经常遇到的CSS兼容性问题，解决办法，常用hack？ CSS定义的权重？ zoom:1清除浮动原理？ 如何修改chrome记住密码后自动填充表单的黄色背景 ？ JavaScript篇 基本数据类型【symbol】？ js内置对象？ 写js的基本规范？ null，undefined 的区别？ call,apply，bind区别及联系？ 什么是window对象? 什么是document对象？ 谈谈原型，原型链，都有什么特点？ 如何实现数组的随机排序？ js如何实现继承？ js创建对象的几种方式？ js延迟加载？ js代码中的”use strict”;是什么意思 ? 使用它区别是什么？ 谈谈你对闭包的理解？ 谈谈你对JSON的理解？ 谈谈你对this的理解？ AJAX是什么，如何创建一个AJAX？ 如何解决跨域？ jQuery篇 Jquery与jQuery UI 有啥区别？ jQuery和Zepto的区别？各自的使用场景？ 针对 jQuery 的优化方法？ jQuery如何同时绑定多个函数？ 其他 node.js适用场景？ ES6相关，Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ 前端性能优化 http状态码，分别代表什么意思？ 一个页面从url输入到页面加载完成都发生了什么？ 面试注意的地方讲项目的时候，展现自己的亮点。比如说，你使用了模块化，那么你就一定要知道什么是模块化，而不是说你会用模块化工具。其实要求并不高，你只要能很好说清楚什么是AMD规范，什么是CommonJs规范，各自的优缺点是什么就够了。 还有很重要的一点是要将面试官往你熟悉的地方引导，你不这样做，面试官还不轻松碾压你。 警惕好像是、可能是、我猜之类的词眼，对自己不太清楚的应该是按照我的理解、给过一点思考时间、我不太懂这个问题需要我从哪个角度解析、我以前遇到类似的问题是怎样这个问题应该也是这样，要让面试官觉得自己即使不太明白也在努力思考。 总结 机会总是留给有准备的人，每一次都要好好对待。 当对自己的技术足够自信的时候，拼的就是RP和面试技巧了。 面试之前，去找找那些大牛们，他们比你都有经验。 平常心对待，只不过是一份工作。 答案请移步]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[所谓的面试经]]></title>
    <url>%2F2016%2F09%2F16%2F%E9%9D%A2%E8%AF%95%2F</url>
    <content type="text"><![CDATA[邀请面试从收到面试邀请时，以下几点必须要特别注意： 哪个地方看到的简历【防止上当受骗】 面试时间、地点、直接负责人 面试官来自哪个部门，技术部还是其他 项目情况，新项目还是有人离职接手他人 技术面无论工作年限以下作为一名合格前端人必须要做到的： 1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。 2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。 3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。 4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。 5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。 6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型 7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们 8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。 9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。 10、JSON —— 作用、用途、设计结构。 对技术个人的理解是注重基础，HTML，CSS，JS,JQ这几个对日常开发基本足够。基础不达标，学框架都是会用框架，这并不是好事。可以关注，但不盲目跟风。这时候又要说到技术是为产品服务的。 HR面薪酬谈判根据公司预算及个人期望值做出判断，这里又是套路与被套路了。记住一句话，先出价的人往往处于被动地位。工资不够，福利来凑。努力经营自己，让自己变得更有价值。换言之，就是难以替代，或者说，替代成本远超过重新招人。 典型问题你还有什么要问我的吗？ 你认为公司最吸引你的地方是什么？ 如果自己有幸入职，该职位具体是做什么的？ 根据我的表现，您认为我以后需要注意什么？ 自己的优势、不足个人具备较强的解决问题能力，对于开发中的问题可独自一人解决。个人认为解决问题能力是最重要的能力，没有之一，无论是沟通能力、表达能力还是其他什么能力，都是为了更好的解决问题。 良好的自控力，平均每天阅读时常达到1小时以上。 目前还没发现什么影响开发的的明显缺点。通过我们之间简短的交流，您觉得我有什么地方需要改进的。 怎样理解前端开发以及前景前端人是最切近用户的一群人，实现界面交互、提升用户体验、通过node.js可实现服务端一些事。与团队成员、UI、部门老大完成产品的更新迭代。 对加班的看法加班就像借钱，救急不救穷。。。 最近在学什么，未来有什么规划吗？如node.js，微信开发等 关注技术前沿但谨慎入坑。最好的一个办法就是以产品为导向，永远记住一句话：技术是为产品服务的 我希望在未来若干年，可能3年，也可能5年。在技术追求精进，在做好本职工作的同时，不断学习诸如设计，后台，管理等方面知识。尝试全栈开发。 暂时想到的就是这些了，以后想起在补充。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在响应式布局下，保证不同元素的相同高度]]></title>
    <url>%2F2016%2F09%2F15%2Fi016%2F</url>
    <content type="text"><![CDATA[在响应式布局中限制不同元素的高度依靠单纯的css恐怕是无能为力了，但我们可以通过jQuery中的matchHeight.js可以将全部所选元素等高。 再有就是将处在同一行的元素等高。原理就是在在同一行元素中选择最高的，然后将所有元素的高度设置成该数值，代码如下： 12345678910111213141516171819202122232425262728293031323334equalheight = function(container)&#123;var currentTallest = 0, currentRowStart = 0, rowDivs = new Array(), $el, topPosition = 0; $(container).each(function() &#123; $el = $(this); $($el).height(&apos;auto&apos;) topPostion = $el.position().top; if (currentRowStart != topPostion) &#123; for (currentDiv = 0 ; currentDiv &lt; rowDivs.length ; currentDiv++) &#123; rowDivs[currentDiv].height(currentTallest); &#125; rowDivs.length = 0; // empty the array currentRowStart = topPostion; currentTallest = $el.height(); rowDivs.push($el); &#125; else &#123; rowDivs.push($el); currentTallest = (currentTallest &lt; $el.height()) ? ($el.height()) : (currentTallest); &#125; for (currentDiv = 0 ; currentDiv &lt; rowDivs.length ; currentDiv++) &#123; rowDivs[currentDiv].height(currentTallest); &#125; &#125;);&#125;//eg比如想具有相同的class的元素有相等的高度$(window).load(function() &#123; equalheight(&apos;.eqheight&apos;);&#125;);$(window).resize(function()&#123; equalheight(&apos;.eqheight&apos;);&#125;);]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QQ飞车]]></title>
    <url>%2F2016%2F09%2F15%2F%E9%A3%9E%E8%BD%A6%2F</url>
    <content type="text"><![CDATA[游戏只玩飞车，不论到什么时候，之前看朋友在玩吃鸡，感觉挺好玩的，也试了试，可能以后会玩，但飞车是肯定会玩，真相只有一个原因，就是自己酷爱车，哈哈，没办法。 玩游戏的成长也可以算是自己心智的成长吧！从刚开始的痴迷，到后来的每天只玩1小时，再到现在的偶尔玩。之前，曾经良心发泄，卸掉，之后又下载。到现在的保留但把控游戏时常。这点，自己做的还是挺好的。毕竟，玩是人的天性，我们得学会把控，而不是谈及游戏就无情排斥。任何事物都有其两面性，我们应辩证的看待。 大师是我向往的，虽然现在自己只是个钻石，我想，谁都想自己是个大神。对游戏，我不排斥，我希望自己可以在游戏中获得成长，无论是心智还是技术。 玩，就撕心裂肺的玩；工作，就完全投入进去，达到 All in 状态。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈JavaScript中this]]></title>
    <url>%2F2016%2F09%2F05%2Fi032%2F</url>
    <content type="text"><![CDATA[作为函数调用this关键字指定的对象取决于函数的调用方式，JavaScript 中的函数的调用有以下几种方式： 作为函数调用 作为对象方法调用 作为构造函数调用 1234567891011var n = &quot;Hello World!&quot;;function example()&#123; console.log(this.n);&#125;example(); //Hello World!var n = &apos;Hello World!&apos;;function example()&#123; this.n=0;&#125;example();console.log(n); //0 结论：当函数直接调用时，该函数的this关键字指向的就是全局对象window。 作为对象方法调用1234567891011121314151617181920212223function getAge()&#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var zhangsan = &#123; name: &apos;张三&apos;, birth: 1990, age: getAge&#125;;console.log(zhangsan.age());//27console.log(getAge()); //NaNvar fn = zhangsan.age;console.log(fn()); //NaNvar name = &apos;Akita&apos;;var dogs = &#123; name:&apos;Collie&apos;, showName: function()&#123; console.log(this.name); &#125;&#125;;console.log(dogs.showName()); //Collievar otherNmae = dogs.showName;console.log(otherName()); //Akita 结论：当使用obj.xxx()的形式调用函数时，里面的this关键字指向的就是对象本身。但是需要注意：在对象方法内部再次定义一个方法，该方法的this关键字又会重新指向全局对象window！这点需要特别注意比如下面这段代码： 123456789101112var zhangsan = &#123; name: &apos;张三&apos;, birth: 1990, age: function()&#123; function getAgeFromBirth()&#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;;console.log(zhangsan.age()); //NaN 在 strict 模式下你会得到的错误就不是 NaN，而是TypeError：Cannot read property ‘birth’ of undefined。 作为构造函数调用12345function Student(name)&#123; this.name=name;&#125;var xiaoming = new Student(&apos;小明&apos;);console.log(xiaoming.name); //小明 指定 this 指向 指定函数的this指向哪个对象，可以用函数本身的apply方法，它接收两个参数，第一个参数就是需要绑定的this变量，第二个参数是Array，表示函数本身的参数。 1234567891011function getAge() &#123; var y = new Date().getFullYear(); return y - this.birth;&#125;var xiaoming = &#123; name: &apos;张三&apos;, birth: 1990, age: getAge&#125;;zhangsan.age(); // 25getAge.apply(zhangsan, []); // 25 利用apply()将getAge()的this指向了xiaoming这个对象，因此函数执行正确。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中call,apply,bind联系与区别]]></title>
    <url>%2F2016%2F08%2F28%2Fi013%2F</url>
    <content type="text"><![CDATA[call/apply/bind方法的来源: call,apply,bind这三个方法都是继承自Function.prototype中的，属于实例方法。 123console.log(Function.prototype.hasOwnProperty(&apos;call&apos;)) //trueconsole.log(Function.prototype.hasOwnProperty(&apos;apply&apos;)) //trueconsole.log(Function.prototype.hasOwnProperty(&apos;bind&apos;)) //true Function.prototype.call()函数实例的call方法，可以指定该函数内部this的指向，然后在所指定的作用域中，调用该函数。并且会立即执行该函数。如： 12345678910111213var zhangsan = &#123; age: 20 //;会报错Uncaught SyntaxError: Unexpected token&#125;;var age = 22;function a() &#123; console.log(this.age);&#125;a(); //22a.call(); //22a.call(null); //22a.call(undefined); //22a.call(this); //22a.call(zhangsan); //20 上述代码中，this如果指向全局对象，则返回22,否则返回20。 call()方法可以传递2个参数，第一个参数是函数执行时所在的作用域，第二个是函数调用时需要传递的参数。第一个参数时必须的，可以是null,undefined,this,其表示函数此时处于全局作用域，第二个参数必须一个个添加。而在apply()方法中，第二个参数必须为数组。 call()方法的应用：调用对象的原生方法或将类数组对象转换为数组1234567var obj = &#123;&#125;; console.log(obj.hasOwnProperty(&apos;toString&apos;)); //false obj.hasOwnProperty = function() &#123; return true; &#125; console.log(obj.hasOwnProperty(&apos;toString&apos;)); //true console.log(Object.prototype.hasOwnProperty.call(obj, &apos;toString&apos;)); //false hasOwnProperty是obj对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。call方法可以解决这个方法，它将hasOwnProperty方法的原始定义放到obj对象上执行，这样无论obj上有没有同名方法，都不会影响结果。要注意的是，hasOwnProperty是Object.prototype原生对象的方法，而call是继承自Function.prototype的方法。 Function.prototype.apply() apply方法的作用与call方法类似，也是改变this指向（函数执行时所在的作用域），然后在指定的作用域中，调用该函数。同时也会立即执行该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数 call与apply的区别：12345function keith(a, b) &#123; console.log(a + b); &#125; keith.call(null, 2, 3); //5 keith.apply(null, [2, 3]); //5 有必要再说一遍：call()第二个参数必须一个个添加【可同时添加多个】，二apply()必须以数组的形式添加。 apply()应用： 找出数组中的最大数 1234var a = [2, 4, 5, 7, 8, 10];console.log(Math.max.apply(null, a)); //10console.log(Math.max.call(null,2, 4, 5, 7, 8, 10)); //10Javascript中是没有提供找出数组中最大值的方法的，使用继承自Function.prototype的apply和Math.max方法，就可以返回数组的最大值。 将数组的空元素变为undefined【利用Array构造函数将数组的空元素变成undefined。】 1console.log(Array.apply(null, [1, , 3])); // [1, undefined, 3] 空元素与undefined的区别在于，数组的forEach()会跳过空元素，但不会跳过undefined和null。 1234567var a = [1, , 3]; a.forEach(function(index) &#123; console.log(index); //1,3 ，跳过了空元素。 &#125;) Array.apply(null,a).forEach(function(index)&#123; console.log(index); ////1,undefined,3 ，将空元素设置为undefined &#125;) 利用数组对象的slice方法，可以将一个类似数组的对象（比如arguments对象）转为真正的数组。当然，slice方法的一个重要应用，就是将类似数组的对象转为真正的数组。call和apply都可以实现该应用。 1234567891011console.log(Array.prototype.slice.apply(&#123;0:1,length:1&#125;)); //[1]console.log(Array.prototype.slice.call(&#123;0:1,length:1&#125;)); //[1]console.log(Array.prototype.slice.apply(&#123;0:1,length:2&#125;)); //[1,undefined×1]console.log(Array.prototype.slice.call(&#123;0:1,length:2&#125;)); //[1,undefined×1]//n为任意数字console.log(Array.prototype.slice.apply(&#123;0:1,length:n&#125;)); //[1,undefined×(n-1)]console.log(Array.prototype.slice.call(&#123;0:1,length:n&#125;)); //[1,undefined×(n-1)]function keith(a,b,c)&#123; return arguments; &#125;console.log(Array.prototype.slice.call(keith(2,3,4))); //[2,3,4] 该方法起作用的前提：被处理的对象必须有length属性，以及相对应的数字键。 Function.prototype.bind()bind方法用于指定函数内部的this指向（执行时所在的作用域），然后返回一个新函数。bind方法并非立即执行一个函数。 123456789var keith = &#123; a: 1, count: function() &#123; console.log(this.a++); &#125; &#125;; keith.count(); //1 keith.count(); //2 keith.count(); //3 上面代码中，如果this.a指向keith对象内部的a属性，如果这个方法赋值给另外一个变量，调用时就会出错. 12345678var keith = &#123; a: 1, count: function() &#123; console.log(this.a++); &#125;&#125;;var f = keith.count;f(); //NaN 上面代码中，如果把count方法赋值给f变量，那么this对象指向不再是keith对象了，而是window对象。而window.a默认为undefined，进行递增运算之后undefined++就等于NaN。 为了解决这个问题，可以使用bind方法，将keith对象里的this绑定到keith对象上，或者是直接调用。 1234567var f = keith.count.bind(keith);f(); //1f(); //2f(); //3keith.count.bind(keith)() //1keith.count.bind(keith)() //2keith.count.bind(keith)() //3 当然，this也可以绑定到其他对象上。 1234567var obj = &#123; a: 100&#125;;var f = keith.count.bind(obj);f(); //100f(); //101f(); //102 同样，我们也可以给bind方法传递参数，第一个参数如果为null或者undefined或者this，会将函数内部的this对象指向全局环境；第二个为调用时需要的参数，并且传递参数的形式与call方法相同。 1234567function keith(a, b) &#123; return a + b;&#125;console.log(keith.apply(null,[1,4])); //5console.log(keith.call(null,1,4)); //5console.log(keith.bind(null, 1, 4)); //keith()console.log(keith.bind(null, 1, 4)()); //5 绑定回调函数的对象: 如果在回掉函数中使用this对象，那么this对象是会指向DOM对象，也就是button对象。如果要解决回调函数中this指向问题，可以用如下方法。 12345678910var o = &#123; f: function() &#123; console.log(this === o); &#125; &#125; $(&apos;#button&apos;).on(&apos;click&apos;, function() &#123; o.f.apply(o); //或者 o.f.call(o); //或者 o.f.bind(o)(); &#125;); 点击按钮以后，控制台将会显示true。由于apply方法（或者call方法）不仅绑定函数执行时所在的对象，还会立即执行函数（而bind方法不会立即执行，注意区别），因此不得不把绑定语句写在一个函数体内。 call，apply，bind方法的联系和区别:第一个参数都是指定函数内部中this的指向（函数执行时所在的作用域），然后根据指定的作用域，调用该函数。都可以在函数调用时传递参数。call，bind方法需要直接传入，而apply方法需要以数组的形式传入。call，apply方法是在调用之后立即执行函数，而bind方法没有立即执行，需要将函数再执行一遍。有点闭包的味道。改变this对象的指向问题不仅有call，apply，bind方法，也可以使用that变量来固定this的指向。[原文链接]：(http://www.cnblogs.com/Uncle-Keith/p/5822549.html)]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《程序员的自我修养》]]></title>
    <url>%2F2016%2F08%2F25%2Fb003%2F</url>
    <content type="text"><![CDATA[这两天，看完了这本书，作者以他多年一线编程经验告诉后人作为一个软件开发人员应注意的地方。其中，提到了很多中肯的建议。这里，我仅摘录自己比较有感触的，并谈谈自己的理解。 天才与普通人 漫画描述1：一个普通人每天都很努力，他头顶上显示的能力槽也在慢慢地增长。而图中的另一个天才，则整天不务正业，当然他头上的能力槽也几乎没有增长。 漫画描述2：经过了长时间的努力，普通人头顶上的能力槽慢慢接近了满格，此时那个天才醒悟并开始了努力。 漫画描述3：又过了一段时间，普通人头顶上的能力槽终于满格了，但此时天才头顶上的能力槽却早已爆表，高出了那个普通人很大一截，那个努力的普通人只好无奈地抬头仰望着那位天才。 漫画描述4：但当普通人默默回过头来，却惊讶地发现有更多的人正同样充满敬意地仰望着他，因为此时的他也早已成为了大多数人眼中的那个佼佼者。 这组漫画非常发人深省，优秀的程序员往往会被同天才或高智商的人联系在一起，但我想告诉你，你周围所看到的那些天才（身边的优秀程序员）只是在你没看到的时候花了更多时间工作或者学习而已，当你也坚持这么做时，你也会变得和他们一样优秀。 常听人说，人与人之间的差距在周末，由此可见，付出的多少决定你能走多远，我想，这句话适用于任何地方。比如说，像我们这些做技术的，没有亲身编码实践，妄图希望看一些技术博客，书籍就获得个人编码能力的提高。这是不存在的，固然它可以开拓我们的视野，但实践得真知，通过亲自编码加深个人的理解，才是我们最应坚持的。 基础打牢了吗基础的重要性不言而喻，房子没打好基础会面临坍塌的风险，技术基础没打好，会面临失业的风险。这绝不是危言耸听，一个没有良好基础的技术人员所掌握的技术都是虚无缥缈的，这就需要我们不时的回看过去的代码可能现在看来它也不过如此吗？真的是这样吗？了解原理吗？网上有个段子说“我们只是代码的搬运工”，没有自己的理解，不懂得原理，只知道这样做可以完成项目。我觉得这是可悲的。技术，出自基础，结于基础。 遵循最佳实践不知大家发现了没，随着互联网的高速发展，技术更是日新月异，框架被源源不断的开发出来，这就需要开发人员找到一个适合自己的学习方式。对于我个人而言，我更偏向于在打牢基础后适时学习一些框架，要明白框架是学不完的，这就需要我们进行取舍。具体到每天的TO DO LIST上。现在，除每天必做任务阅读，英语外，我每天只写3-5件需要完成的任务，决不能超过这个范围，不然就是为完成任务而完成了，也不会深入思考为什么要这样，是否还有其他方式。而这个，是我在将近1年的时间中摸索出来的，并且在日后还会不断完善。总而言之一句话，我始终相信”实践得真知“。 保持好奇心并乐于探索新事物这点，我觉得自己做的还算不错的。在技术上，我会关注一些前辈的博客，公众号，时常逛逛前端优质社区，如div.io,技匠社等,虽然其中有些内容看不透彻，但自己还是乐在其中。时常觉得自己周围有一群优秀的人，便会不断激励自己。同样，在生活中，我还关注了Spenser,stormzhang,秦小明等优质公号，从他们的言语中，会时不时的触发大脑神经，原来事情是这样的。有时候会觉得当事情发展到一定阶段时，一切都是水到渠成的，并没有过多的神秘可言。 睡眠使你更加强大曾经，我是个夜猫子，没有11.30之前睡过觉，大概从今年年初的时候，突然意识到自己不能这样下去了。无论是对身体还是白天的学习都是白害而无一利的。现在，我10.30就基本进入睡眠状态了，偶尔会11点多睡觉，但这种情况基本可以忽略不计。每天6点准时起床，制定今日计划，开始一天的生活。 你不应该成为一匹独狼学会与人合作是每个人都应进修的课程，无论个人能力多么强大，在团队面前都是渺小的，没有团队的支持，一切将寸步难行。在团队合作中，成员之间可能会因价值观，思考角度不同产生隔阂，但这并不是无解的，一位优秀的领导者，会统筹成员之间所擅长的东西，达到1+1&gt;&gt;2的效果。 程序员更加国际化在《驱动力》一书中，为我们描述了这样一幅景象，程序员就职若干公司，在家完成工作，这样省去通勤时间，提高开发效率。程序员成为一个单独的个体，可能早上在这家公司工作，下午在另一所公司，晚上进行跨国合作完成项目。Google就已经尝试这种做法，我不知道这样的愿景在近几年会出现在中国，但我相信，在未来一定会出现。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HEXO+Github搭建自己的博客]]></title>
    <url>%2F2016%2F08%2F21%2F%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[这里，记录下自己博客搭建过程中遇到的坑，供给需要的人参考。 软件安装Node-windows 32 位安装包下载地址 Node-windows 64 位安装包下载地址 Git 下载地址 SSH配置12$ cd ~/. ssh$ ssh-keygen -t rsa -C &quot;邮件地址@youremail.com&quot; Generating public/private rsa key pair.Enter file in which to save the key (/Users/your_user_directory/.ssh/id_rsa):&lt;回车就好&gt; 打开本地C:\Documents and Settings\Administrator.ssh\id_rsa.pub文件,复制以上内容 注意：此文件里面内容为刚才生成人密钥。如果看不到这个文件，你需要设置显示隐藏文件。准确的复制这个文件的内容，才能保证设置的成功。 点击右上角头像处的下拉列表 Settings-→SSH and GPG keys -→ 右上角 New SSH key添加key 测试1$ ssh -T git@github.com The authenticity of host ‘github.com (207.97.227.239)’can’t be established.RSA key fingerprint is 16:27:ac:a5:76:28:2d:36:63:1b:56:4d:eb:df:a6:48.Are you sure you want to continue connecting (yes/no)? 输入yes Hi cnfeat! You’ve successfully authenticated, but GitHub does not provide shell access. 设置用户信息$ git config –global user.name “userName”//你的用户名$ git config –global user.email “userName@163.com”//填写自己的邮箱 – 查看用户名密码去掉后面的双引内容 本机已成功连接到github如有问题 , 请重新设置 , 常见错误参考 常见错误参考 常见错误参考 安装HEXO1npm install hexo-cli -g //全局安装 注意Github Pages的Repository名字是特定（两个要一致）的，比如我Github账号是webykj，那么我Github Pages Repository（GitHub仓库）名字就是webykj.github.io。 上传到Github需要执行以下命令 1npm install hexo-deployer-git --save 若没有执行以上命令，将会提醒deloyer not found:git 配置Deployment 在_config.yml文件中，找到Deployment，然后按照如下修改： 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 1234Permission denied (publickey).fatal: Could not read from remote repository.Please make sure you have the correct access rightsand the repository exists. 原因：没有设置好public key所致。 SSH配置详解 更改主题【nexT】1git clone https://github.com/iissnan/hexo-theme-next 在站点配置文件中找到theme更改为next 添加搜索插件1npm install hexo-generator-searchdb --save 之后再主题配置文件中找到local search 将false改为true 常用命令123456$ hexo n == hexo new --新建文章$ hexo g == hexo generate --生成页面$ hexo s == hexo server --启用本地浏览器预览（localhost:4000）$ hexo d == hexo deploy --部署博客$ hexo d -g #生成部署$ hexo s -g #生成预览 HEXO主题配置及优化 更换字体cdn托管：到\themes\next\layout_partials\head external-fonts.swig文件fonts.googleapis.com 改成 fonts.cat.net hexo官网 博客搭建 hexo安装配置详解 HEXO博客优化 hexo常用特效 hexo常见问题解决方案 HEXO底部配置]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>HEXO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[致自己]]></title>
    <url>%2F2016%2F08%2F20%2F%E8%87%B4%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[纯粹哭过、疯过、爱过、恨过，我就是我，一个有态度的男孩。我不在乎外界对我的看法，因为我知道在追求卓越的路上都是孤独的。这不是在为自己找借口，只想保持初衷，用心做好每件事。 对话一拿什么拯救我这颗躁动的心，我不甘平庸，却流于平庸。难道这就是人们常说的浮躁吗？常听人们说现在的年轻人都比较浮躁，有时候我也反思自己。我不知道自己该归于哪一类，对于这一点，我认为，去到外面看看，体验下真实的世界，也许，就会得到结果。比如说租房，这几天自己就在找房子，或多或少有些收获吧！ 再比如说，找工作这件事，有时候投简历并不是为了一份工作，可能是想要了解自己现有水平和市场的差距，以备明确自己的方向，也有可能是《钱没给到位，受委屈了》职场上的委屈可以拿钱来补偿，这一点，个人还是比较赞同的。人与人，与公司之间本身就是一种价值交换。这无可厚非，任何人都不能站在道义的制高点去评判他人。说到这里，让我想起了曾经看到的一篇文章，《把自己当做一个企业去思考》大致讲的是，我们不能为了一份工资去工作，虽然它是生活的保障，但这样，并不能发挥自己真正的潜力。对于潜力，相信每个人都有所体会，人在绝境时的爆发时的潜能是任何人无法想象的。好了，时间也不早了，就这样吧！与君共勉。 对话二收起你的玻璃心，那除了证明你无能外，再也无法证明什么。现在你可以没钱，但不能不值钱。可能有人会问，值钱还会没钱吗？对，还真会这样。听过这样一句话，30前考拼命，30岁之后靠拼命。对此，我不能再赞同了。 什么是格局，格局就是格局，说不上来，只知道它很重要。可能自己段位低，无法领略，但我相信，在不久的将来，我会明白。但对于前半句话，还是值得一说的，曾看过一篇文章说，30岁钱不拼命，30后还有工作吗？可能有点极端，但是，但仔细想想，似乎有那么些道理，想想10年前的生活，再看看现在，时代真不是以你的意志而改变的，唯有适应时代，紧跟都不一定跟得上，这就需要我们全力以赴做好每件事，坦率的说，我对我所从事的工作谈不上多么热爱，只知道努力可以获得相对其他行业更高的工资。我想，有这样想法的人大有人在，关键在于以什么样的心态来做，愿为这份工作付出他人无法付出的，在技术上追求卓越，这本身就说明一切。试想，谁会为自己的梦想甘愿付出一切，就好比你给一个快要饿死的人说，前方100米有100万，他会跑过去吗，那样只会让他死的更快。他现在只想填饱肚子，钱，现在对他就是纸。我不知道我这样表达是否得当，我只想说，任何人都无法站在道德的制高点去评判别人对错，唯有保持沉默，事只有发生在自己身上才会有感触。现在你可以没钱，但不能不值钱。可能有人会问，值钱还会没钱吗？对，还真会这样。]]></content>
      <categories>
        <category>about</category>
      </categories>
      <tags>
        <tag>about</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery【一】]]></title>
    <url>%2F2016%2F08%2F20%2Fi014%2F</url>
    <content type="text"><![CDATA[jQuery中的节点操作追加元素12$(&apos;#p&apos;).append(&apos;向p中追加元素&apos;);$(&apos;追加元素到p&apos;).appendTo(&quot;#p&quot;); 前置元素12$(&apos;#a&apos;).prepend(&apos;向p中前置元素&apos;);$(&apos;前置元素到p中&apos;).appendTo(&apos;p&apos;);*/ 插入元素12$(&apos;#a&apos;).before(&apos;节点元素前插入节点元素&apos;);$(&apos;#a&apos;).after(&apos;在p之后插入元素&apos;); 插入节点元素前后必须用标签包起来123$(&quot;&lt;b&gt;插入到节点元素后&lt;/b&gt;&quot;).insertAfter(&quot;#a&quot;);$(&quot;&lt;b&gt;插入到节点元素前&lt;/b&gt;&quot;).insertBefore(&quot;#a&quot;);//区分insertAfter,insertBefore与after,before 几种删除节点的方法1234var $li=$(&quot;ul li:eq(1)&quot;).remove();$(&quot;ul&quot;).append($li);//把刚删除的元素节点从新添加到ul元素中去$(&quot;ul li&quot;).remove(&quot;li[title!=a]&quot;);//将ul元素下title属性不等于&quot;a&quot;的li元素删除 $(&quot;ul li:eq(1)&quot;).empty();//清空ul节点下第2个li元素的内容 复制节点1$(this).clone(true).appendTo(&quot;ul&quot;); 替换节点12$(&quot;p&quot;).replaceWith(&quot;&lt;strong&gt;你最不喜欢的水果是？&lt;/Strong&gt;&quot;);$(&quot;[name=&apos;rp&apos;]&quot;).replaceWith(&quot;&lt;tr&gt;&lt;td&gt;gg&lt;/td&gt;&lt;/tr&gt;&quot;); jQuery中的属性过滤器[attribute=value] 属性过滤器，全字符匹配1$(&apos;#a&apos;).attr(&apos;value&apos;,&apos;aa&apos;); [attribute!=value] 同 not([attr=”value”])1$(&quot;a&quot;).not(&quot;[href*=&apos;http://&apos;]&quot;).append(&quot;更改内容&quot;); [attribute^=value] 取出属性以指定字符串开头的元素1$(&quot;a[href^=&apos;http:&apos;]&quot;).attr(&quot;target&quot;,&quot;_blank&quot;).css(&quot;background-color&quot;,&quot;gray&quot;); [attribute$=value] 取出属性以指定字符串结尾的元素12$(&quot;a[href$=&apos;edu.cn&apos;]&quot;).css(&quot;background-color&quot;,&quot;red&quot;).append(&quot;单属性过滤器&quot;);$(&quot;a[rel=&apos;google&apos;][target=&apos;_blank&apos;]&quot;).css(&quot;background-color&quot;,&quot;green&quot;).append(&quot;多属性过滤器&quot;);]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[何为朋友]]></title>
    <url>%2F2016%2F08%2F13%2F%E6%9C%8B%E5%8F%8B%2F</url>
    <content type="text"><![CDATA[任何人，说出的每句话、做出的每件事都有其特定的目的。 你的朋友就是你的真实写照，你的财富是你最好5位朋友的平均，事实上，也就是这样。正所谓你是什么样的人就会交什么样的朋友。有时候，看一个人值不值的交往，看他的朋友就能知道答案。对于我来说，我对朋友的要求比较高，也不能这样说，属于那种宁缺毋滥的。现在，自认为能跟我算上朋友属于个位数。 正如Spenser叔说的，“最好的爱情，是势均力敌；最好的关系，是价值对等”。这里，爱情不再讨论范围内，今天，只说关系。人生在世数十年，一辈子的朋友终究只会是那么几个，多数还是过客。与其说是朋友，不如说是三观接近的一群人，这样更为贴切。 你要接受这个世界的相对冷漠和适度功利，并且认为这就是保持正常运转，和最优化配置的必要手段。 当彼此咖位不在同一个数量级的时候，你能做的，就是静静仰望，不打扰，免得自取其辱。 社交的本质，就是资源的相互匹配。而能进行社交的前提，是是两个人对等的江湖地位。 对于圈子不同要不要强融的问题，没有正确答案，我更倾向硬着头皮强融啊，自己想进入某个圈子当然是有其特定的价值。能聊得来就坎，聊不来各奔东西。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Session与Cookie]]></title>
    <url>%2F2016%2F08%2F10%2Fcookie%2F</url>
    <content type="text"><![CDATA[Session与Cookie概括Web应用程序有个很重要的特性就是可以记录用户状态，记录此类信息的载体有两种。session在浏览器关闭后失效，cookie理论永久有效。 Cookie 定义cookie 12setcookie(&apos;abc&apos;,$user,time()+60*60*24,&apos;/&apos;);//语法setcookie(键名，值，有效时间，路径) 使用cookie 1$_COOKIE[&apos;键名&apos;]; Session 定义session 12$_SESSION[&apos;UID&apos;]=123;//$_SESSION[‘session的名’]=session的值 使用session 1$_SESSION[‘session名’] 区别与联系 session在浏览器关闭后失效，cookie理论永久有效。 cookie存放在客户端，session存放在服务端。 session相对于cookie更安全，敏感信息存放在session中。。 session在一定时间内会存放在服务器上，考虑到性能，与cookie配合使用更好。 cookie有大小限制【4K】，session没有。 session依赖cookie，因为session id在客户端。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git or SVN]]></title>
    <url>%2F2016%2F08%2F01%2Fgit%2F</url>
    <content type="text"><![CDATA[什么是SVN简单来说，SVN是一种版本控制工具，尤其在企业中，应用广泛。 SVN与CVS CVS不支持文件重命名，如果重命名一个文件的话，之前的修订历史记录就会丢失。 CVS没有原子性提交，如果提交很多文件，提交到一半的时候出错，那就尴尬了。 CVS只支持文本文件，无法提交二进制文件。 SVN解决了这几个问题，并且加入了一些新的特性，如： SVN对二进制文件的版本管理，使用了节省空间的保存方法，只保存和上一版本的不同之处。 目录也有版本历史。重命名、复制和删除也会保存在版本历史记录中，当然，要用SVN的重命名来操作。 分支的开销比较小。 SVN使用场景 早上到达公司，从服务器拉取项目最新代码到本地。 切换到自己的分支，开始工作，每隔一个小时向服务器自己的分支推送一次代码。 下班时间快到了，把自己的分支合并到服务器主分支上，一天的工作完成，并反映给服务器。 如果不能连接到服务器，基本上无法工作。看上面第二步，如果服务器不能连接上，就不能提交、还原、对比，等等。而且如果太多人同时操作，服务器就会面临过大的压力，也可能处理过慢或者崩溃。 SVN最佳实践 鼓励频繁提交 确定分支流程 定义主干原则并坚守 不把逻辑修改和代码格式化混在一起 不相干的代码分开提交 保持工作代码库的“干净” 在企业内部SVN没有什么问题，但在开源社区呢？这时候，诞生了Git。 什么是GitGit是一个分布式版本控制软件，它与SVN最大的不同就是基于分布式的理念。 GitHub工作流 Git工作流 最后再来谈谈包管理 一个程序只做一件事，并做好。 Node.js的包管理器应该是世界最著名的包管理器了。npm有一个公共组件库，可通过命令或package.json来下载所依赖的组件。 什么是npm npm是“npm is not an acronym”，它不是Node Package Manager的缩写。 通过命令直接修改package.json1npm install &amp;lt;name&amp;gt; [--save|--save-dev|--save-optional] [--save-exact] npm install 会直接安装npm上某个模块（name）的最新版本，也可以选择带上参数。 –save表示这个模块会直接出现在package.json中的dependencies属性中。前提是要有package.json这个文件，后面也是一样。 –save-dev表示这个模块会直接出现在package.json中的devDependencies属性中。关于dependencies和devDependencies的区别，假设一个人下载了你的模块并且在代码中使用，他只需要你的功能，并不需要你的测试代码，或者文档构建器。这时候最好把这些开发阶段使用的包放在devDependencies中。 –save-optional表示这个模块会直接出现在package.json中的optionalDencies属性中。如果某个模块是可选的——这意味这您在您的依赖代码中做了备选方案（fallback）处理——就放在optionalDependencies中，npm安装的时候会尽量下载和安装这个模块，但是如果下载失败了，npm也不会报错，仅仅跳过去。 还有一个参数-g，意思是将模块安装在全局目录。Linux的全局目录默认是/usr/local/或者安装node的地方，而本地安装是当前项目的node_modules目录。在本地安装的包一般使用require( )来把模块引入到代码中，而使用全局安装的模块可以在命令行中直接使用。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发必看的文章]]></title>
    <url>%2F2016%2F07%2F28%2F%E5%89%8D%E7%AB%AF%E5%BC%80%E5%8F%91%E5%BF%85%E7%9C%8B%E6%96%87%E7%AB%A0%2F</url>
    <content type="text"><![CDATA[技术 常用代码集合 小胡子哥 前端九段 理解Glup和Webpack]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《思考致富》【一】]]></title>
    <url>%2F2016%2F07%2F25%2F%E6%80%9D%E8%80%83%E8%87%B4%E5%AF%8C%2F</url>
    <content type="text"><![CDATA[何为机遇 机遇总喜欢从后门悄悄溜进来，常常以灾难、不幸或暂时的挫折掩人耳目。也许这正是多数人认不出机遇的原因吧。 你的“QQS”等级“QQS”指得是质量（Quality）、数量（Quantity）、外加适当的合作精神（Spirit），三者合在一起就是完美的推销模式。 服务质量应被理解为，以永远追求更高效率为目标，以最有效的方式完成与你的职位相关的各个细节工作。 服务数量应被理解为，将随时提供尽可能的服务当作一种习惯，目的在于通过实践和经验培养出更高超的技能，以提高服务数量。这里再次强调了习惯的重要性。 服务精神应被理解为，一种愉快和谐的行为习惯，它能促进同事间和上下级间的合作。 何为信念 信念是积聚财富的起点！ 信念是所有奇迹以及科学原理无法解释的奥秘的基础。 信念是唯一能够治疗失败的良药。 信念是一种元素，在与祈祷结合时能产生“化学反应”，让人类思维直通无穷智慧。 信念是一种要素，能把人类有限脑力创造的普通思想震波转化为同等的精神力量。 信念是开发和运用“无穷智慧”的唯一媒介！ 失败的31个主因，换言之，也是‘成功’要尽可能避免的 不理想的遗传基因 缺乏明确的人生目标 缺乏雄心壮志 教育不足 缺乏自律 疾病缠身 摄取太多不利于健康的食物； 错误的思考习惯；持消极态度表达负面思想； 误用或滥用性行为； 缺乏正确的体育锻炼； 由于不正确呼吸导致缺乏新鲜空气供应。 童年时期不良环境的影响 拖拉 缺乏恒心 消极的个性 缺乏对性冲动的控制 无法控制“不劳而获”的欲望 缺乏果断的决策力 具有6种基本恐惧的一种或多种 选错配偶 过分谨慎 选错事业伙伴 迷信与偏见 职业选择错误 缺乏专一目标 肆意挥霍的习惯 缺乏热情 不够宽容 放纵 不善于合作 非自身努力而得来的力量 蓄意不忠 自私和虚荣 猜测 缺少资本 更多。。。 一年一度的自我分析1．我是否实现了今年制定的目标？（你应该制定一个明确的年度目标，作为人生大目标中的一部分） 2．我是否提供了力所能及的最好服务？或者，我能否改进这一服务？ 3．我是否提供了力所能及的最多服务？ 4．我是否在工作中一直保持着和谐的精神状态？ 5．我是否允许拖拉的习惯降低了工作效率？如果真这样，究竟影响到了什么程度？ 6．我的个性是否有所改进？是如何改进的？ 7．我是否自始至终贯彻执行了自己的计划？ 8．我是否在任何时候都果断明确地作出了决策？ 9．我是否让六种恐惧之一或更多，降低了工作效率？ 10．我是过度谨慎呢，还是不够谨慎？ 11．我与同事间是否保持着和谐愉快的关系？如果不那么愉快，责任完全在我，还是部分在我？ 12．我是否因为不够专注而浪费了精力？ 13．我是否能以宽容的胸怀面对所有问题？ 14．我以何种方式提高了自己的服务能力？ 15．我放纵过自己的哪种习惯？ 16．无论公开地，还是私底下，我是否表现出了自私的一面？ 17．我对待同事的行为是否能赢得他们的尊敬？ 18．我的判断和决策是基于猜测，还是基于准确的思维和分析？ 19．我是否遵循了提前安排时间、提前计划支出和收入的习惯？在这些方面，我是否太保守了？ 20．我把多少时间花在了徒劳无益的努力上，其实，原本可以用这些时间去做更有意义的事情？ 21．为了在来年更有效率，我该如何重新安排时间、改变习惯？ 22．我是否因做过使良心不安的事情而内疚？ 23．我在哪些方面提供了分内之外的更多、更好的服务？ 24．我是否对他人不公平？如果有，是在哪方面不公平？ 25．如果我是自己未来的服务对象，那么我对得到的服务满意吗？ 26．我选择的职业合适自己吗？如果不合适，为什么？ 27．我的服务对象对我满意吗？如果不满意，原因是什么？ 28．按照成功法则来看，我目前处于什么程度？ 评估要尽可能的真实，这是一次与内心的对话。 自我分析问卷1．你经常抱怨“身体不舒服”吗？如果是，原因是什么？ 2．你会为小事指责他人吗？ 3．你经常在工作上出错吗？如果是，为什么？ 4．你的言谈尖刻伤人吗？ 5．你是否刻意避免与人交往？如果是，为什么？ 6．你经常消化不良吗？如果是，原因是什么？ 7．你是否认为生活无聊，未来没有希望？如果是，原因是什么？ 8．你喜欢自己的工作吗？如果不喜欢，为什么？ 9．你经常怜惜自己吗？如果是，为什么？ 10．你忌妒那些比自己优越的人吗？ 11．你会花更多时间考虑成功还是失败吗？ 12．年龄越大，你是越有自信还是越不自信？ 13．你是否从错误中吸取过宝贵的经验教训？ 14．你是否让某位亲人或熟人感到担忧？如果是，为什么？ 15．你是否有时会“心不在焉”，有时又陷入失意的深渊？ 16．谁对你最具有激励作用？原因是什么？ 17．你能容忍本来可以避免的消极影响吗？ 18．你是否不在意个人外表？如果是，何时、为什么不在意？ 19．你已经学会了用忙碌来“消愁解忧”，从而摆脱其干扰了吗？ 20．如果任由别人来替你思考，你是否会认为自己是个“没有骨气的懦夫”？ 21．你是否不注意心灵的净化，导致自身中毒，变得暴躁易怒？ 22．有多少原本可以预防的干扰令你感到苦恼？为何要容忍？ 23．你是否会利用酒精、毒品或香烟来“安定情绪”？如果是，为何不试着用意志力呢？ 24．是否有人在你耳边“唠唠叨叨”？如果有，原因是什么？ 25．你是否有个明确的主目标？如果有，是什么？你打算用什么计划来实现它？ 26．你有六种恐惧中的某一种吗？如果有，是什么？ 27．你有办法保护自己抵御他人的消极影响吗？ 28．有是否有意应用自我暗示法来激发积极心态？ 29．你最看重的是什么，是物质财富，还是控制自己思想的权力？ 30．你是否容易受到他人影响，结果违背了自己的判断？ 31．今天你的知识宝库或精神状态中添加过任何有价值的东西吗？ 32．你是选择客观地面对使自己不愉快的环境，还是选择逃避责任？ 33．你是在认真分析一切错误和失败中受益，还是喜欢推诿责任？ 34．你能说出自己的三个最大弱点吗？你在采取哪些措施补救？ 35．你是否因为同情鼓励他人而将忧虑传染给了自己？ 36．你是否从日常经历中挑选出那些有助于个人进步的教训或影响？ 37．总体上看，你的表现是否通常会给他人带来消极影响？ 38．你最讨厌别人的什么习惯？ 39．你会有自己的主见，还是会受他人影响？ 40．你是否已经学会了营造一种心态，以抵御所有令人气馁的影响力？ 41．你的工作能激发自己的信心和希望吗？ 42．你是否意识到自己有足够的精神力量，而使内心免受各种形式的恐惧？ 43．你的信仰能帮助你保持积极心态吗？ 44．你认为自己有责任分担别人的忧虑吗？如果有，为什么？ 45．你是否相信“物以类聚、人以群分”？通过分析与自己交好的朋友，你对自己有哪些了解？ 46．与你交往密切的人和与你体验到的幸福之间有无联系？如果有，是什么联系？ 47．有哪些你视为朋友的人，实际上可能是你最大的敌人，因为他们给你带来了消极影响？ 48．你用什么原则判断谁对自己有帮助，谁对自己有伤害？ 49．从心理上讲，你最亲密的同事比你略高一筹，还是低你一等？ 50．在每天24小时内，你在下列事情上花费了多少时间？ （1）工作（2）睡眠（3）娱乐休闲（4）获取有用知识（5）无所事事 51．在你的朋友当中，哪些人 （1）给你的鼓励最多（2）给你的告戒最多（3）给你的阻挠最多（4）以其他方式帮助你最多 52．你最担心的是什么？为什么会容忍它？ 53．当别人主动提供建议时，你会毫不质疑地接受，还是先分析其动机？ 54．你最渴望的东西是什么？你打算获得它吗？你愿意为它而压抑其他欲望吗？为了得到它，你每天会投入多少时间？ 55．你经常改变主意吗？如果是，为什么？ 56．你做事通常都能善始善终吗？ 57．你是否容易对他人的事业或职业头衔、学位或财富而动心？ 58．别人对你的评价是否会轻易影响你？ 59．你是否因别人的社会经济地位而迎合他们？ 60．你认为谁是当今最伟大的人？这个人在哪方面比你出众？ 61．你花了多少时间研究与回答这些问题？（分析和回答全部问题至少应该花费一天时间） 了解自己的终极武器。。。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mouseout与mouseleave的区别]]></title>
    <url>%2F2016%2F07%2F25%2Fmouseout%E4%B8%8Emouseleave%2F</url>
    <content type="text"><![CDATA[区别与联系联系：都是鼠标移出元素时触发. 区别： 不论鼠标指针离开指定元素还是该元素子元素，都会触发 mouseout 事件。 只有在鼠标指针离开指定元素时，才会触发 mouseleave 事件。 通过实例来区分1234567891011121314151617&lt;div id=&quot;1&quot;&gt;&lt;a&gt;这是一个a&lt;/a&gt;&lt;/div&gt;&lt;div id=&quot;2&quot;&gt;&lt;/div&gt;$(function ()&#123; $(document).ready(function()&#123; $(&quot;#1&quot;).mouseout(function()&#123; //此方式下，当鼠标移出&lt;a&gt;元素也会触发 $(&quot;#2&quot;).css(&quot;background-color&quot;,&quot;yellow&quot;); &#125;); &#125;); $(document).ready(function()&#123; $(&quot;#1&quot;).mouseleave(function()&#123; //只有鼠标移出#1&lt;div&gt;时才会触发 $(&quot;#2&quot;).css(&quot;background-color&quot;,&quot;blue&quot;); &#125;); &#125;);&#125;);]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[页面跳转常用方法]]></title>
    <url>%2F2016%2F07%2F20%2F%E9%A1%B5%E9%9D%A2%E8%B7%B3%E8%BD%AC%2F</url>
    <content type="text"><![CDATA[Browser 客户端跳转（3 种）123&lt;meta http-equiv=&quot;refresh&quot; content=&quot;停顿秒数;URL=跳转网址&quot; /&gt;&lt;script language=”javascript”&gt;location.replace(&quot;跳转网址&quot;);&lt;/script&gt;&lt;script language=”javascript”&gt;location.href=&quot;跳转网址&quot;;&lt;/script&gt; Server 服务器端跳转1header(&quot;Location: 跳转网址&quot;); 注意： Server 服务器端的页面跳转不会给 Browser 客户端任何提示，所以很多时候是不够友好的，如果希望用户能够看到一些提示信息，则最好是使用客户端跳转。 header 命令之前不能有任何的输出。（原因：因为头信息是最先输出到客户端的，若在头信息之前再有输出则就问题了） 其它跳转12345678&lt;?php// Server 服务器端的页面跳转不会给 Browser 客户端任何提示，所以很多时候是不够友好的，// 可以考虑下面的方式echo “&lt;script&gt;alert(‘登录成功’);location.href =’index.php’;&lt;/script&gt;”;?&gt;]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈闭包]]></title>
    <url>%2F2016%2F07%2F18%2Fi008%2F</url>
    <content type="text"><![CDATA[什么是闭包，如何理解 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。 先看个案例12345678910111213141516&lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; (function ()&#123; var liArr=document.getElementsByTagName(&apos;li&apos;); for(var i=0;i&lt;liArr.length;i++)&#123; liArr[i].onclick=function ()&#123; console.log(i) &#125; &#125; &#125;)()&lt;/script&gt; 以上代码想输出被点击li的索引号，但结果并非如此，每次输出都是4。 原因在于匿名函数没有变量 i，所以它必须向上查找，在全局环境中找到了 i。 当for循环运行后，全局变量中的 i 变成了4。此时当你点击文字的时候，会调用其绑定的函数，而该函数运行的时候，发现自己没有 i，就会取得全局环境中的 i。 解决办法1 将var更改为let,不知道的点击查看let关键字，干嘛用的？ 解决办法2–采用闭包 12345678910111213141516for(var i=0;i&lt;dom.length;i++)&#123; dom[i].onclick=function(i)&#123; return function()&#123; console.log(i); &#125;; &#125;(i);&#125;//当然也可以这样写for(i = 0;i&lt;nodes.length;i+= 1)&#123; nodes[i].onclick = (function(i)&#123; return function() &#123; console.log(i); &#125; //不用闭包的话，值每次都是4 &#125;)(i);&#125; 来，看看有没有理解 12345678 for(var i=0;i&lt;dom.length;i++)&#123; dom[i].onclick=function(t)&#123; return function()&#123; console.log(t); //1 console.log(i); //3 &#125;; &#125;(i);&#125; 闭包的特性 函数内再嵌套函数 内部函数可以引用外层的参数和变量 参数和变量不会被垃圾回收机制回收 123456789101112 function fn() &#123; // Local variable that ends up within closure var num = 666; var sayAlert = function() &#123; alert(num); &#125; num++; return sayAlert;&#125; var sayAlert = fn(); sayAlert(); //执行结果应该弹出的667 执行fn后,内部变量会存在,而闭包内部函数的内部变量不会存在使得Javascript的垃圾收机制GC不会收回fn所占用的资源因为fn的内部函数的执行需要依赖fn中的变量,这是对闭包作用的非常直白的描述。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的婚姻观]]></title>
    <url>%2F2016%2F07%2F12%2F%E5%A9%9A%E5%A7%BB%E8%A7%82%2F</url>
    <content type="text"><![CDATA[10.1对国家是意义非凡的，对我来说，同样也是。2年前的今天，是大姐结婚的日子；16年正月二姐也结婚了。转眼间，2年过去了，除了感慨时间飞速流逝外，更多的还是想说说自己的婚姻观。 偶然间，听老姐说，老妈跟她唠叨说啥时候能轮到我。哎，没办法，可怜天下父母心。但站在我的角度来说，我并不喜欢过早的结婚，我希望自己能在事业上有所收获，我觉得没有事业的婚姻是虚无缥缈的，在我不能给家人提供优质的生活前，这些都不在我的考虑范围内。在我们当地，结婚普遍提前，更毕业没多久就准备忙孩子的终身大事，可能是由于男女比例严重失衡吧！我不希望别人站在世俗的角度说我怎们怎么样。同样的，我也没必要在乎他人的看法，那些对我都不重要。我现在最重要的就是赚更多的钱，有钱不一定过得好，但没钱一定过得不好。钱带给我的除了物质生活外，更多的是视野。正如Spenser说的“钱是好的，钱带给人自由，年轻人应该尽可能快速赚到第一桶金，在年轻的时候拥有财富，是幸福的事情” 正如《稀缺：我们是如何陷入贫穷和忙碌的》中说的，贫穷心态的影响是长久的，难以轻易消除的，无论是物质上的紧缺还是精神上的僵化，都是根深蒂固的。 真正决定你的未来的，是时代的趋势，甚至是你的出身。 –Spenser 很幸运，我出生在和平年代，没有战乱。老爸也给我提供了非常不错的生活，老爸赚的不一定很多，但足以支撑起这个家。我不知道老爸养3个孩子需要付出多大的代价，只知道老爸真的很辛苦很辛苦。在以后的日子里，我将尽自己最大的努力让他们生活的开心快乐。 我现在唯一能做的，就是尽可能的赚更多的钱。我不能在该拼搏的时候选择安逸，唯有奋起直追，做一个好儿子。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP引入文件]]></title>
    <url>%2F2016%2F07%2F08%2Fphp%E5%BC%95%E5%85%A5%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[require:如果引用文件不存在则报错，终止运行后续代码；不检查是否已经引入此文件。文件方式—require (‘function3.php’);通常放在 PHP 程序的最前面，PHP 程序在执行前，就会先读入 require 所指定引入的文件， 如果出 现错误是致命的。 require_once :如果引用文件不存在则给出报错，终止运行后续代码；检查是否已经引入此文件，如果已经引入则不再引入(同一个文件只读取一次)。 include：如果引用文件不存在则报错，继续运行后续代码；不检查是否已经引入此文件。文件方式include (‘function3.php’);可以放在 PHP 程序的任何一个位置，PHP 程序在执行到时，才会先读入 include 所指定引入的文件，如果出现错误将会提示。 include_once：如果引用文件不存在则报错，继续运行后续代码；检查是否已经引入此文件，如果已经引入则不再引入(同一个文件只读取一次)。require_once 或者 include_once “检查是否已经引入此文件”，主要用来避免因多次引入同一个文件。导致函数、类等被多次定义。 文件路径：以下为建立路径所使用的几个特殊符号，及其所代表的意义。以“./”开头：代表目前所在的目录。以“../”开头：代表上一层目录。以“/”开头：代表根目录。 代码终结：Exit(); 推出程序Die(“abc”); 终止程序Return; PHP管理变量Isset判断变量是否定义过Unset取消变量的定义$a=’’;unset($a); //取消变量的定义if(isset($a)){ //isset判断变量是否定义过 echo ‘ok…‘;}else{ echo ‘no…‘;} Empty该函数用于检查某个变量的值是否为空（””、 0、 “0”、 NULL、 FALSE、 array()、var $var 以及没有任何属性的对象都将被认为是空），如果为空则返回true，否则返回false。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript DOM编程艺术》【二】]]></title>
    <url>%2F2016%2F07%2F08%2Fb002-2%2F</url>
    <content type="text"><![CDATA[图片库改进：如果想用Javascript给某个网页添加一些行为，就不应该让Javascript代码对这个网页的结构有任何依赖，凸显了采取预防性措施的必要性。结构化程序设计原则之一：函数应该只有一个入口和一个出口。但集中将出口集中在函数的开头是可以接受的。 Javascript与HTML标记分离：element.event = function(){…}，这里的event不限onclick、onkeypress。 共享onload事件网页加载完毕时会触发一个onload事件，这个事件与window对象相关联。即window.onload = function(){…}。若需要绑定的函数较多时，一个弹性的解决方案是addLoadEvent，代码如下： 1234567891011function addLoadEvent(func) &#123; var oldonload = window.onload; if(typeof window.onload != &apos;function&apos;) &#123; window.onload = func; &#125; else&#123; window.onload = function() &#123; oldonload(); func(); &#125; &#125;&#125; 未完待续。。。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js获取访问者ip信息脚本]]></title>
    <url>%2F2016%2F07%2F05%2Fi021%2F</url>
    <content type="text"><![CDATA[以下是新浪脚本代码 12345678910111213&lt;script type=&quot;text/javascript&quot;src=&quot;http://int.dpool.sina.com.cn/iplookup/iplookup.php?format=js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;//&lt;![CDATA[ alert([ remote_ip_info.country, remote_ip_info.province, remote_ip_info.city, remote_ip_info.isp, remote_ip_info.start, remote_ip_info.end ].join(&apos;&apos;));//]]&gt;&lt;/script&gt; 知乎讨论:怎样用 JavaScript 程序获取客户的 IP 地址？]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中clientX,screenX,pageX,offsetX的异同]]></title>
    <url>%2F2016%2F06%2F28%2Fi018%2F</url>
    <content type="text"><![CDATA[pageX/pageY:鼠标相对于整个页面的X/Y坐标。整个页面的意思指整个网页的全部，比如说网页很宽很长，宽2000px，高3000px，那pageX,pageY的最大值就是它们了。 特别说明：IE不支持！ offsetX/offsetY:得出的结果跟pageX/pageY一样，既然如此，它有什么存在价值？ 特别说明：只有IE支持！相当于IE下的pageX,pageY. screenX/screenY:顾名思义，就是鼠标在屏幕上的坐标。screenX,screenY的最大值不会超过你的屏幕分辨率。 clientX/clientY：事件发生时鼠标在浏览器内容区域的X/Y坐标（不包含滚动条）。浏览器内容区域即浏览器窗口中用来显示网页的可视区域，注意这个可视，也就是说需要拖动滚动条才能看到的区域不算。当你将浏览器窗口缩小时，clientX/clientY的最大值也会缩小，但始终，它们的最大值不会超过你浏览器可视区域。 特别说明：IE下此属性不规范，它们的最小值不是0而是2，也就是说IE下的clientX/clientY与火狐下的始终大2px 持续完善中。。。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《JavaScript DOM编程艺术》【一】]]></title>
    <url>%2F2016%2F06%2F25%2Fb002%2F</url>
    <content type="text"><![CDATA[先看个小例子：创建insertAfter方法 DOM常用的5个方法： getElementById getElementsByTagName gettElemensByClassName getAttribute setAttribute DOM中的D表示文档，O表示对象，M表示模型。其中，对象分为3种： 用户定义的对象 内建对象，如Array,Math,Date等 宿主对象，由浏览器提供的对象，,如window.open,window.blur. getElementsByClassName兼容性处理：12345678910111213141516//node表示DOM树中搜索起点 function getElementsByClassName(node,classname)&#123; if(node.getElementsByClassName)&#123; //使用现有方法 return node.getElementsByClassName(classname); &#125;else&#123; var results=new Array(); var elems=node.getElementsByTagName(&quot;*&quot;); for(var i=0;i&lt;elems.length;i++)&#123; if(elems[i].className.indexOf(classname) != -1)&#123; results[results.length]=elems[i]; &#125; &#125; return results; &#125; &#125; 小结： 一份文档就是一颗节点树。 节点分为不同类型：元素，属性，文本节点等。 getElementById将返回一个对象，该对象对应着文档里的一个特定的元素节点。 getElementsByTagName和getElementsByClassName将返回一个数组，分别对应文档里一组特定的元素节点。 每一个节点都是一个对象。 获取和设置属性：getAttribute是一个函数，只有一个参数： 123object.getAttribute(attribute)...getAttribute不属于document对象，所以不能通过document对象调用，调用方法： var paras=document.getElementsByTagName(“p”);//方法一：for(var i=0;i&lt;paras.length;i++){ var title_text=paras[i].getAttribute(“title”); if(title_text!= null){ alert(title_text); }}//方法二：for(var i=0;i&lt;paras.length;i++){ var title_text=paras[i].getAttribute(“title”); if(title_text) alert(title_text);}… setAttributegetAttribute是一个函数，有2个参数： 1object.setAttribute(attribute,value) 用setAttribute改变原有属性的值：12345678var paras=document.getElementsByTagName(&quot;p&quot;);for(var i=0;i&lt;prras.length;i++)&#123; var title_text=paras[i].getAttribute(&quot;title&quot;); if(title_text)&#123; paras[i].setAttribute(&quot;title&quot;,&quot;brand new title text&quot;); alert(paras[i].getAttribute(&quot;title&quot;)); &#125;&#125; childNodes属性：该属性可获取任何一个元素所有的子元素，他是一个所有子元素的数组。 显示body所有子元素的总个数： 1234567function countBodyChildern()&#123; var body_element = document.getElementsByTagName(&quot;body&quot;)[0]; alert(body_element.childNodes.length);&#125;//在页面加载时执行window.onload = countBodyChildren; nodeType属性：语法： 1node.nodeType nodetype得值是个数字，而不是像“element”,”attribute”那样的字符串。 nodeType只有12种，但只有3种有实用价值： 元素节点的nodeType属性值为1 属性节点的nodeType属性值为2 文本节点的nodeType属性值为3 动态改变属性值：1234567function showPic(whichpic)&#123; var source = whichpic.getAttribute(&quot;href&quot;); var placeholder = document.getElementById(&quot;placeholder&quot;); placeholder.setAttribute(&quot;src&quot;,socuse); var text = which.getAttribute(&quot;title&quot;); var description = document.getElementById(&quot;description&quot;);&#125; nodeValue属性改变文本节点的值： 12345678910node.nodeValue//改变属性的值function showPic()&#123; var source=whichpic.getAttribute(&quot;href&quot;); var placeholder=document.getElementById(&quot;placeholder&quot;); placeholder.setAttribute(&quot;src&quot;,source); var text=whichpic.getAttribute(&quot;title&quot;); var description=document.getElementById(&quot;description&quot;); description.firstChild.nodeValue=text;&#125; firstChild与lastChild属性：123node.firstChildnode.childNodes[0]node.lastChild 动态创建标记传统方法：document.write和innerHTML DOM方法：creatElement,createTextNode,appendChild和insertBefore 123456789101112131415161718192021window.onload=function ()&#123; var pra=document.createElement(&quot;p&quot;); var div=document.getElementById(&quot;div&quot;); div.appendChild(pra); var txt=document.createTextNode(&quot;hello world!&quot;); pra.appendChild(txt);&#125;//我更倾向这种写法 window.onload=function ()&#123; var pra=document.createElement(&quot;p&quot;); var txt1=document.createTextNode(&quot;This is &quot;); var em=document.createElement(&quot;em&quot;); var txt2=document.createTextNode(&quot;my&quot;); var txt3=document.createTextNode(&quot; content.&quot;); var div=document.getElementById(&quot;div&quot;); pra.appendChild(txt1); em.appendChild(txt2); pra.appendChild(em); pra.appendChild(txt3); div.appendChild(pra);&#125; insertBefore方法，这里需要注意没有insertAfter方法，但我们可以编写它，代码如下：123456789function insertAfter(newElement,targetElement)&#123; var parent=targetElement.parentNode; if(parent.lastChild==targetElement)&#123; parent.appendChild(newElement); &#125;else&#123; parent.insertBefore(newElement,targetElement.nextSibling); &#125; //nextSibling表示目标元素的兄弟元素&#125; 最终代码如下：1234567891011121314151617function preparePlaceholder()&#123; if(!document.createElement) return false; if(!document.createTextNode) return false; if(!document.getElementById) return false; if(!document.getElementById(&quot;pic&quot;)) return false; var placeholder=document.createElement(&quot;img&quot;); placeholder.setAttribute(&quot;id&quot;,&quot;placeholder&quot;); placeholder.setAttribute(&quot;src&quot;,&quot;img/a4.jpg&quot;); placeholder.setAttribute(&quot;alt&quot;,&quot;This is a photo&quot;); var description=document.createElement(&quot;p&quot;); description.setAttribute(&quot;id&quot;,&quot;description&quot;); var txt=document.createTextNode(&quot;Choose an pic&quot;); description.appendChild(txt); var gallery=document.getElementById(&quot;pic&quot;); insertAfter(placeholder,gallery); insertAfter(description,placeholder);&#125; 持续更新完善中。。。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[预定义常量和数组]]></title>
    <url>%2F2016%2F06%2F22%2F%E9%A2%84%E5%AE%9A%E4%B9%89%E5%B8%B8%E9%87%8F%E4%B8%8E%E6%95%B0%E7%BB%84%2F</url>
    <content type="text"><![CDATA[PHP预定义常量12345echo __FILE__; //返回当前常量名 一定要大写echo &apos;&lt;hr&gt;&apos;;echo __LINE__;//返回当前行号__LINE__ ：文件中的当前行号。__FUNCTION__ : 函数名称,自 PHP 5 起本常量返回该函数被定义时的名字（区分大小写）。 PHP 预定义数组123echo &apos;&lt;pre&gt;&apos;;print_r($_SERVER);echo &apos;&lt;/pre&gt;&apos;; $_SERVER：获得服务器信息,根据服务器不同，$_SERVER 中的变量值和变量个数会有差别，不过一般都可以找到如下变量。其中包括： ①REMOTE_ADDR正在浏览当前页面用户的 IP 地址,即客户端的 IP 地址。 echo $_SERVER[‘REMOTE_ADDR’]; //获取客户端IP地址 ②HTTP_REFERER访问当前页面的上一个页面地址【注：防盗链技术】 $_GET:内置预定义数组——接收表单以 get 方式发送过来的数据。 ①当form表单没有写method时，表单默认以get方式提交。 ②文件名与第一个参数之间用?连接，之后的多个参数名用&amp;连接，例如： 12http://localhost:8000/index.php?cat=apache&amp;id=157&amp;name=lisiLocalhost:/文件名.php?参数名1=参数值1&amp;参数名2=参数值2&amp;参数名3=参数值3 ③a连接以get方式提交，例如： 1&lt;a href=&quot;form1-act.php?age=20&amp;uid=11&amp;flg=test&quot;&gt;测试&lt;/a&gt; Get与post提交区别 ①Get为显示提交，在地址栏中能看见，post为隐示提交，地址栏中不能看见。 ②post相对于get而言更加安全。 ③get对发送参数的大小有限制，而post没有限制。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[document.body.scrollTop与document.documentElement.scrollTop的兼容]]></title>
    <url>%2F2016%2F06%2F20%2Fi023%2F</url>
    <content type="text"><![CDATA[这两天在写一个JS滚动监听，在[display]的时候发现了这个问题：chrome居然不认识document.documentElement.scrollTop！ 看前辈们的文章，纷纷表示如果有文档声明（即网页第一句的docType）的情况下，标准浏览器是只认识documentElement.scrollTop的，但chrome虽然我感觉比firefox还标准，但却不认识这个，在有文档声明时，chrome也只认识document.body.scrollTop. 由于在不同情况下，document.body.scrollTop与document.documentElement.scrollTop都有可能取不到值，那到底网页的scrollTop值怎么得到呢？ 解决办法： 12345678//方法一：var sTop=document.body.scrollTop+document.documentElement.scrollTop;//方法二：function getscroll()&#123; var scrollTop=document.documentElement.scrollTop || window.pageYOffset || document.body.scrollTop; return scrollTop; &#125; 理由如下： 因为document.body.scrollTop与document.documentElement.scrollTop两者有个特点，就是同时只会有一个值生效。比如document.body.scrollTop能取到值的时候，document.documentElement.scrollTop就会始终为0；反之亦然。所以，如果要得到网页的真正的scrollTop值,这两个值总会有一个恒为0，所以不用担心会对真正的scrollTop造成影响。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[获取网页宽高]]></title>
    <url>%2F2016%2F06%2F12%2Fi015%2F</url>
    <content type="text"><![CDATA[Javascript: 网页可见区域宽： document.body.clientWidth 网页可见区域高： document.body.clientHeight 网页可见区域宽： document.body.offsetWidth (包括边线的宽) 网页可见区域高： document.body.offsetHeight (包括边线的高) 网页正文全文宽： document.body.scrollWidth 网页正文全文高： document.body.scrollHeight 网页被卷去的高： document.body.scrollTop 网页被卷去的左： document.body.scrollLeft 网页正文部分上： window.screenTop 网页正文部分左： window.screenLeft 屏幕分辨率的高： window.screen.height 屏幕分辨率的宽： window.screen.width 屏幕可用工作区高度： window.screen.availHeight 屏幕可用工作区宽度： window.screen.availWidth JQuery:$(document).ready(function(){alert($(window).height()); //浏览器当前窗口可视区域高度alert($(document).height()); //浏览器当前窗口文档的高度alert($(document.body).height());//浏览器当前窗口文档body的高度alert($(document.body).outerHeight(true));//浏览器当前窗口文档body的总高度 包括border padding margin}) 用jQuery监听浏览器窗口的变化$(window).resize(function () { //当浏览器大小变化时 alert($(window).height()); //浏览器时下窗口可视区域高度 alert($(document).height()); //浏览器时下窗口文档的高度 alert($(document.body).height()); //浏览器时下窗口文档body的高度 alert($(document.body).outerHeight(true)); //浏览器时下窗口文档body的总高度 包括border padding margin});]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《稀缺》]]></title>
    <url>%2F2016%2F06%2F12%2F%E7%A8%80%E7%BC%BA%2F</url>
    <content type="text"><![CDATA[阅读一本书并不是要把书中的每一行的每个字都认一遍，而是较真地弄明白作者的意思，并理解作者的思想，才能进一步真正掌握一本书的观点、视角以及可能的现实应用。 每本书都有其必然的阅读难度，这本《稀缺》的阅读难度指数为8（中文图书阅读难度指数衡量的是所有中文图书的难度，难度最高为24，最低为1）。 先做10道题1.在《稀缺》一书引言的第4页中，黑体字显示了如下这句话：稀缺，是“拥有”少于“需要”的感觉。这句话的意思是：（ ） A.稀缺是人们心中比较结果的感觉 B.稀缺是客观存在的某种稀有之物 C.稀缺是人与人之间相互比较的感觉 D.稀缺是生存需要无法得到满足的感觉 2.在《稀缺》一书引言的第8页中，黑体字显示了如下这句话：我们的思想会自动而强有力地转向未得到满足的需要。作者从这句话出发，引申出了如下哪些结论：（ ） A.稀缺会俘获大脑 B.稀缺的感觉会渐渐成为潜意识 C.稀缺会控制人的注意力 D.稀缺会被人脑控制 3.在《稀缺》一书引言的第15页中，作者运用了一个词汇：带宽，并宽松地界定了这个词汇，原文是：就是心智的容量，包括两种能力，分别是认知能力和执行控制力。稀缺会降低所有这些带宽的容量，致使我们缺乏洞察力和前瞻性，还会减弱我们的执行控制力。根据作者的这段说法，思考一下我们自己每天的现实生活会发生什么改变：（ ） A.将影响我们每天吸收到的信息量 B.将影响我们每天处理的信息量 C.将影响我们处理完信息后的行为 D.将影响我们控制信息的能力 4.在第23页，黑体字的内容为：稀缺，会迫使人做出选择。所有抽象的事物都会变得具体起来。作者这句话能够说明如下哪种情况：（ ） A.稀缺的人通常不看未来而是专注眼前 B.稀缺的人通常不看理论而是专注行为 C.稀缺的人通常不看规律而是专注操作 D.抽象的事物是由大量具体的事件构成的 5.在第24页，黑体字的内容为：当稀缺俘获大脑时，人们的注意力会集中在如何以最有成效的方式去利用自身资源上。作者这句话的意思是：（ ） A.人们在吃不饱的时候，最后一口面包会细嚼慢咽 B.人们在钱不多的时候，最后几元钱也会节省下来 C.人们在时间不够的时候，会利用好睡觉前的最后几分钟 D.人们在朋友不多的时候，会格外地在意有限的一两位朋友 6.在《稀缺》一书中作者提供了很多实例。请你尝试判断一下如下情况：正当员工感觉自己的任务无穷无尽时，上级通知他们，这个月，实际上只有最后两项任务了。你觉得这时，他们的表现将是：（ ） A.非常高兴，草率地完成最后这两项任务 B.尽快完成，尽量维持与之前同等的工作态度和质量 C.没有太大变化，一如既往地完成最后这两项任务 D.专注度得到大幅度的提高，聚精会神地完成剩下的任务 7.我们可以说稀缺会令人“专注”，也可以说稀缺会导致我们产生“管窥”之见——只能一门心思地专注于管理手头的稀缺。管窥实际上指的是用眼睛通过“管子”看待事情。作者的意思是：（ ） A.眼睛看不到的事物人们就不会关注 B.眼睛看不到的事物人们索性就不会处理 C.眼睛看不到的事物其实就不重要 D.眼睛看不到的事物根本就不存在 8.在第40页中，有一段黑体字为：当稀缺将我们的大脑俘获时，我们不会通过对得失利弊的谨慎思考来进行权衡。可见，我们用管窥的方式来应对稀缺，既有利，又有弊。通过原书的阅读，你认为作者实际的意思是：（ ） A.利大于弊 B.弊大于利 C.作者没有明确表示 D.作者认为多数人对此都没有意识 9.作者针对“稀缺”这一主题写成了一本书，并研究了读者读书的专注目的——作者提到了心理学术语：目标抑制。请思考一下，如果你平时读书的目的可能是以下4种，那么你觉得如下4个可能的目的，哪个更容易实现：（ ） A.扩大自己的知识和眼界 B.提升自己的理解能力 C.跟上时代发展的脚步 D.具体改善自己的实际生活 10.人们平时会吸收来自外界的各种信息，其实，吸收信息的过程有时会被自己无意识地抑制。作者指出一种抑制就是自上而下的，人们思想上会对所关注的事物进行有意识的选择，从而忽视其他信息。如下哪种情况符合这个意思：（ ） A.人们在吃饱后还会注意其他更好吃的食物 B.妇女在怀孕后会发现周围有很多孕妇 C.收入低的人在抱怨工作压力大时会发现周围许多同事都有同感 D.朋友少的人并不会感受到自己的交际圈窄 小结答案： 1~5: A ABC AC ABC B6~10: D B D D C 坦率的讲，我直接做，对了5道，有2道是半对半错。按照书上的说法来看，自认为还不错。测评本身并没有多大的意义，关键是给了我们一次了解自己的机会，这是最重要的。一本书，其实就是作者的人生压缩版。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识PHP]]></title>
    <url>%2F2016%2F06%2F05%2Fphp%2F</url>
    <content type="text"><![CDATA[PHP变量命名规则 第一个字符必须是字母、下划线组成，但是不能以数字开头。 PHP 是弱类型语言， 变量不须定义就可以直接使用， 并且不需要声明它们的类型。比如$a=1;不需要写int $a=1; PHP 的变量名区分大小写，如$A 和$a 是两个不同的变量,但函数名却不区分大小写。 避免为变量和函数起相同的名字。虽然这是允许的，但是容易混淆。 PHP输出语句echo echo+单引号 则字符串中书写的变量名会被原样显示，单引号效率更高，尽可能用单引号。 echo+双引号 则字符串中书写的变量名会被识别并求值。虽然如此，我们应该为双引号字符串中的 变量加上大括号，例如：echo “{$x}”。 有的时候我们也可以使用字符串的连接。在 PHP 中，不像 Java 那样使用加号”+”，而是使用圆点”.”。 区分单双引号123456//当变量写在单引号中会原样输出 $y=&quot;23&quot;; echo &apos;$y=&apos;.gettype($y).&apos;&lt;br/&gt;&apos;; //$y=integer//当变量写在双引号中，变量的值会被替换出来 $y=&quot;23&quot;; &quot;$y=&quot;.gettype($y).&apos;&lt;br/&gt;&apos;; //23=integer//当变量写在双引号中，要注意变量要用大括号括起来 echo &quot;&#123;$y&#125;x&quot;.gettype($y).&apos;&lt;br/&gt;&apos; //23xinteger print()函数Print()函数和 echo()函数两者的功能几乎完全一样， 但有一点不同就是 echo()函数无返回值，print()函数有返回值，且 echo()函数稍快于 print()函数，推荐使用 echo。 print_r()函数用于输出复杂变量（数组、对象）的值，主要用来调试程序。 var_dump(变量)显示输出值和类型，如果是字符串还输出长度 PHP数据类型转换 B/S与C/SB/S 浏览器/服务端 特点：基于浏览器来使用或访问(例如：淘宝、阿里巴巴) 优点：任何时间 任何地点都可以使用网络来访问 缺点：客户端没有数据处理能力，只能提交到服务器来处理 C/S 客户端/服务器 特点：能安装 (例如：微信、QQ) 优点：能自动记录数据，发挥客户端PC的数据处理能力 缺点：对操作系统和硬件配置有一定要求，客户端需要安装软件 B/S程序运行原理 Request(GET+POST) 请求，指访问某个网页的网址请求以及和请求一起传递的参数 Response响应 在PHP中主要体现为右服务器生成好并返回给浏览器的HTML代码 Session有效会话期间 从用户开始浏览某个网站到浏览器关闭的期间有效，可以用来存储用户的相关信息]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《高性能HTML5》]]></title>
    <url>%2F2016%2F05%2F31%2Fb001%2F</url>
    <content type="text"><![CDATA[第一章 概述HTML5 概念：不仅仅是指最新版本的 HTML 标记语言，还包含了很多被现代浏览器所支持的新技术，例如 CSS3、嵌入式音频/视频、Canvas、WebSocket、应用程序缓存、本地存储、索引数据库、文件API、地理位置等。什么是高性能页面加载时间浏览器性能网络性能开发效率 第二章 开发原则浏览器工作原理HTML 解析为一颗 DOM 树。DOM 树和 CSS 样式表结合起来构成渲染树（Firefox 中渲染树被称作框架树）。根据渲染树，浏览器开始绘制。改进性能减少 HTML 中元素的数量减少重绘（效果更明显）动态改动 DOM 和 CSS 样式时有两点需要考虑改动的元素在 DOM 树的深度，越深则改动就越独立，对其他节点影响越少，所以能改多深就改多深。对 DOM 有多次操作，尽量合并到一次做完而不是分成一次一次地去做。CSS 放到 head 标签内（避免白屏），script 放到 body 标签的尾部（避免延迟页面元素的渲染）使用特性检测，而不是浏览器版本号检测。 第三章 性能准则影响页面加载时间的因素（按强弱排序）减少 HTTP 请求使用 CDN 加速避免空的 src 或 href 属性值增加过期头启 GZIP 压缩把 CSS 放在头部把 JavaScript 放到尾部避免使用 CSS 表达式删除不使用的 CSS 语句对 JavaScript、CSS 进行代码压缩减少重绘减少 HTTP 请求理解并行连接HTTP1.1 协议很明确限制了单个用户不能在同一时间保持2个以上的连接。大部分浏览器突破了这个限制。充分利用浏览器并发，将资源文件散列到不同的域名。但 DNS 查询耗时。合并资源文件使用图片精灵减少重绘规定图片的宽和高不要用表格布局定义字符集不要重组 DOM 第四章 响应式网页设计CSS3 媒介查询自适应图片弹性栅格 第五章 理解页面重用机制第六章 页面模板使用IE的兼容模式（通常情况下应该关闭，除非由于历史原因不得不使用），可以通过以下 meta 标签做到 1&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt; 其中，http-equiv=”X-UA-Compatible”告诉IE（IE8 以上支持）将要设置兼容模式状态。content属性确定了采用什么样的兼容模式规则。IE=edge告知浏览器不要采用兼容模式而总是采用最新版本的规则来渲染。chrome=1告诉IE如果用户安装了 Google Chrome Frame（GCF）插件，那么启用它，以 Chrome 内核的渲染方式渲染网页。 为 iPhone 使用 Viewport: 1&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt; 第七章 导航ID 属性选择器的性能是最高的（但比含标识符的选择器高的不多）。因为标识符可以重复使用，所以应该使用含标识符的选择器而不是 ID 属性选择器，牺牲这点性能是值得的。试图让所有浏览器展示完全一样的效果有时候并不是可取的。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网页字体em的使用]]></title>
    <url>%2F2016%2F05%2F28%2Fi011%2F</url>
    <content type="text"><![CDATA[关于em这个字体单位，我一直比较纠结。只知道它是一种相对长度单位，默认1em=16px(即浏览器默认字体大小）。但em使用时并不是简单的1em=16px这么算，以下为引用内容： 任意浏览器的默认字体高都是16px。所有未经调整的浏览器都符合: 1em=16px。那么12px=0.75em,10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明 Font-size=62.5%，这就使em值变为 16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将你的原来的px数值除以10，然后换上em作为单位就行了。看了这个我非常纳闷，默认1em＝16px，但这却不合设计者的要求，又手动调整为1em＝10px，这样12px=1.2em。。。这样绕来绕去的，不如直接设置为12px得了。使用em据说是它可以自动调整，对用户体验好，但我觉得，与其让它自动调整，不如就把字体设置大点。 看到有些文章推荐网页使用em作为字体单位，并列举了这样做的几点好处，其中有一条是“国外的大部分网站能够调整的原因在于其使用了em作为字体单位”，但网页设计者们不要忘了，国外都是英文网站,英文默认10px就可以阅读，而汉字则要12px以上才能看清楚，所以适合的才是最好的。 我们按照上文引用中的用法，来做个测试： 12body&#123;font-size:62.5%;&#125;p&#123;font-size:1.2em;text-indent:2.4em;width:600px;&#125; 在firefox截图如下： 可以很明显地看到字体由于小于12px而模糊不清。如果你网页上大段大段的文字都是这个样子，用户感觉是很糟糕的。 注：IE及chrome正常，都为12px左右，其中chrome有一个bug：不能显示12px以下大小的字体，所以到底兼容性如何还是未知数。 鉴于em使用的麻烦度与不兼容性，我觉得网页字体还是不要用em的好，要用就把它相对设大点，以免出现上图的情况。另外，如果觉得小字体对用户不好的话，就设置font-size:14px吧，这样在什么分辨率下都足以看清了。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我眼中的全栈工程师]]></title>
    <url>%2F2016%2F05%2F26%2F%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E5%85%A8%E6%A0%88%E5%B7%A5%E7%A8%8B%E5%B8%88%2F</url>
    <content type="text"><![CDATA[全栈工程师的利 在自由职业市场，全栈工程师是最闪耀的明星。 全栈工程师还是天生的创业者。 全栈工程师的弊 容易贪大求全，导致迷失自我。 容易掉进技术的深渊，痴迷技术是好事，但技术存在的原因是解决问题。 全栈工程师是指，一个能处理数据库、服务器、系统工程和客户端的所有工作的工程师。根据项目的不同，客户需要的可能是移动栈、Web栈，或者原生应用程序栈。简单来说，全栈工程师就是可以独立完成一个产品的人。当客户让他去做一些舒适区之外的工作时，他敢于迎难而上，并成功完成任务。 我眼中的全栈更多的事“一专多长”,就好比下图说的： 解决问题，而不是醉心技术公司存在的意义是在于解决用户的问题，而员工存在的意义是在于解决公司的问题。能解决问题的工程师就是好的工程师。商业公司本质上都是为了赚更多的钱，不论是降低成本、扩大用户群、增加成交量、优化性能等，这一点，必须要明确。此时，个人与公司是一体的，别想着坑公司，到头来，害的还是自己。 什么是全栈工程师]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS总结]]></title>
    <url>%2F2016%2F05%2F20%2Fi012%2F</url>
    <content type="text"><![CDATA[CSS实用代码汇总 多行文本未知高度垂直居中12345678910111213141516171819202122232425262728//css*&#123;margin:0;padding:0;&#125;.box&#123; height:200px; width:300px; background:pink; margin:30px auto; font-size:0;&#125;.box:before&#123; content: &apos;&apos;; display: inline-block; vertical-align: middle; width: 0; height: 100%;&#125;.text&#123; display: inline-block; font-size:16px; vertical-align: middle;/* 保证文字垂直居中 */&#125;//html&lt;div class=&quot;box&quot;&gt; &lt;p class=&quot;text&quot;&gt; 多行文本未知高度垂直居中-by 一丝多行文本未知高度垂直居中-by 一丝多行文本未知高度垂直 居中-by 一丝 &lt;/p&gt;&lt;/div&gt; 实现原理：vertical-align的对齐是需要有参照物的，那么box 容器通过 before 生成一个高度 100% 的「备胎」，他的高度和容器的高度是一致的，相对于「备胎」垂直居中，在视觉上表现出来也就是相对于容器垂直居中了。 12text-decoration:overline/underline/line-through/blink [浏览器不支持]font-style:iatlic/oblique 斜体（italic）是一种简单的字体风格，对每个字母的结构有一些小改动，来反映变化的外观。倾斜（oblique）文本则是正常竖直文本的一个倾斜版本。 通常情况下，两种效果在浏览器中看上去完全一样。 如何让height100%起作用我们都知道，要想让页面width:100%;可以通过直接设置width:100%实现，但如果是高度呢？直接设置height:100%;无法起作用。 这就需要我们理解浏览器的计算原理了。 事实上，浏览器根本就不计算内容的高度，除非内容超出了视窗范围(导致滚动条出现)。或者你给整个页面设置一个绝对高度。否则，浏览器就会简单的让内容往下堆砌，页面的高度根本就无需考虑。 但这并不意味着我们不能没有办法实现： 123456789&lt;html style=&quot;height: 100%;&quot;&gt; &lt;body style=&quot;height: 100%;&quot;&gt; &lt;div style=&quot;height: 100%;&quot;&gt; &lt;p&gt; 这样这个div的高度就会100%了 &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 可以通过给html,body设置height:100%;实现。但随之也带了一系列问题： Margins 和 padding 会让你的页面出现滚动条，也许这是你不希望的。 如果你的元素实际高度大于你设定的百分比高度，那元素的高度会自动扩展。 文字溢出隐藏并显示省略号。1overflow:hidden; white-space:nowrap; text-overflow:ellipsis; 自定义文本选中12::selection&#123;color:#fff; background:#333;&#125;::-moz-selection&#123;color:#fff;background:#333;&#125; 引用自定义字体12345@font-face&#123;font-family: xujinglei; src: url(&apos;xujinglei.ttf&apos;),url(&apos;xujinglei.eot&apos;); //IE9+&#125;div&#123;font-family:xujinglei; font-size:18px; &#125; 常用标题12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;h2 class=&quot;title&quot; data-text=&quot;hello world&quot;&gt;&lt;/h2&gt;.title&#123; width:1000px; margin:20px auto; position:relative; &#125;.title:before&#123; content:&apos;&apos;; display:block; border-top:1px solid #ccc;&#125;.title:after&#123; content:attr(data-text); display:block; position:absolute; padding:0 20px; background:#fff; color:#666; top:0; left:50%; transform:translate(-50%,-50%);&#125;//less写法.title(@bg:white)&#123; width:1000px; margin:20px auto; position:relative; text-transform:uppercase; white-space:nowrap; &amp;:before&#123; content:&apos;&apos;; display:block; border-top:1px solid #ccc; &#125; &amp;:after&#123; content:attr(data-text); position:absolute; top:0; left:50%; padding:0 20px; background:@bg; transform:translate(-50%,-50%); &#125;&#125;]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[北京，是我的福地]]></title>
    <url>%2F2016%2F05%2F17%2F%E5%8C%97%E4%BA%AC%EF%BC%8C%E6%88%91%E7%9A%84%E7%A6%8F%E5%9C%B0%2F</url>
    <content type="text"><![CDATA[北京，是我的福地； 北京，是我的福地； 北京，是我的福地。 我愿用我的青春奉献给这座城市。我，在路上。。。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何成为一名卓越的前端工程师]]></title>
    <url>%2F2016%2F05%2F13%2F%E5%89%8D%E7%AB%AF%E6%94%BB%E5%9F%8E%E7%8B%AE%2F</url>
    <content type="text"><![CDATA[原文为勾三股四翻译如何成为一名卓越的前端工程师，这是篇好文章，这里仅摘录我认同部分，并践行。 我在 web 领域工作越长时间，我就越意识到区分人才和顶尖人才的并不是他们的知识——而是他们思考问题的方式。很显然，知识在很多情况下是非常重要而且关键的——但是在一个快速发展的领域，你前进和获取知识的方式 (至少在相当长的一段时间里) 会比你已经掌握的知识显得更加重要。更重要的是：你是如何运用这些知识解决每天的问题的。 人才可分为两类，技巧型和技术型，前者主要凭经验，后者则通过思考来解决问题。 别光解决问题，想想究竟发生了什么 很多人埋头写 CSS 和 JavaScript 直到程序工作起来了，然后就去做别的事情了。我通过 code review 发现这种事经常发生。 我发现很多情况下，当你遇到问题的时候，你只是解决当下的问题罢了。但是如果你永远不花时间理解问题的本源，你将一次又一次的面对相同的问题。花一些时间找出为什么，这看上去费时费力，但是我保证它会节省你未来的时间。在完全理解整个系统之后，你就不需要总去猜测和论证了。 阅读规范文档 当同一份代码在两个或更多浏览器的渲染结果不同时，你应该花些时间确定哪个效果是正确的，并且以此为标准写代码。你的解决方案应该是对未来友好的。 阅读别人的代码 自己独立解决问题绝对是个不错的方式，但是这不应该是你唯一的方式，因为它很快就会让你稳定在某个层次。阅读别人的代码会让你开阔思维，并且阅读和理解别人写的代码也是团队协作或开源贡献必须具备的能力。 我着实认为很多公司在招聘新员工的时候犯的最大错误是他们只评估应聘者从轮廓开始写新代码的能力。我几乎没有见过一场面试会要求应聘者阅读现有的代码，找出其中的问题，并修复它们。缺少这样的面试流程真的非常不好，因为你作为工程师的很多时间都花费在了在现有的代码的基础上增加或改变上门，而不是搭建新的东西。 好好利用GitHub 把你学到的东西都记录下来根据我的经验，写作、演讲、做 demo 是强迫自己完全深入理解一件事的最佳方式。就算你写的东西没有人看，整个过程也会让你受益匪浅。 比如，我现在维护的Blog! 以上这些与大家共勉。。。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用dom方法]]></title>
    <url>%2F2016%2F05%2F12%2Fi010%2F</url>
    <content type="text"><![CDATA[DOM常用方法 getElementById(id): 获取有指定惟一ID属性值文档中的元素; getElementsByTagName(name): 返回当前元素中有指定标记名的子元素的数组; hasChildNodes(): 返回一个布尔值，指示元素是否有子元素; getAttribute(name): 返回元素的属性值，属性由name指定； appendChild(element): 将element插入到当前元素后面; createElement(element): 创建一个新的element; createTextNode(text): 以text为内容创建一个新的text节点; insertBefore(new_node, old_node): 将new_node插入到old_node前面一个位置.当然，也可以自己创建个insertAfter(),点击产看 DOM的常用属性 childNodes: 返回当前元素所有子元素的数组; firstChild: 返回当前元素的第一个下级子元素; lastChild: 返回当前元素的最后一个子元素; nextSibling: 返回当前元素后面一个位置的元素; previousSibling: 返回当前元素前面一个位置的元素; parentNode: 返回当前元素的父节点.]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[chrome无法显示12px以下字体]]></title>
    <url>%2F2016%2F05%2F08%2Fi007%2F</url>
    <content type="text"><![CDATA[今天在写页面的时候遇到个小bug，比如设置字体为10px甚至8px。但按照常规设置字体大小后，在chrome下浏览页面会觉得不如想象中小。没错，默认情况下chrome中的字号不能小于12px。 查看有关资料后，找到解决办法： 1234.fz10 &#123;-webkit-text-size-adjust:none; font-size:10px;&#125; 就是这个属性：1-webkit-text-size-adjust:none; 设置之后，chrome下的字体就不会有12px的限制了。 另：中文字体小于12px后会变得难以阅读，一般也不常用。小于12px的字体应该只应用于英文段落或数字。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[赢了游戏，输了人生]]></title>
    <url>%2F2016%2F05%2F02%2F%E8%B5%A2%E4%B8%8E%E8%BE%93%2F</url>
    <content type="text"><![CDATA[在老一辈人眼里，游戏就是毒品，对青少年戕害不浅。可能是因为孩子学习成绩不好，但试问，成绩差是因为玩游戏吗？恐怕不是这样吧。我身边就有这样的人，特别迷恋游戏，但学习成绩也丝毫不差，可能你会认为这是个特例，但如果不止一个呢。除此之外，我发现他们身上都有一种特质，自控力超强。说一不二，说到做到。 具体到我而言，我也玩游戏，但对像lol 农药 穿越并不感冒。只玩飞车，说到飞车，还是自己从小就喜欢车，是自己从小就养成的，并不是因为玩了飞车才喜欢车的。没办法，每当心情压抑时，就来决战秋名山吧！ 在我周围，也不乏沉溺游戏无法自拔的，早早辍学打工，我不知道他们是怎么想的。我是这样理解的，你可以玩，可劲的玩，但有个前提，通过它养活自己，如果你觉得你可以，当我没说。如果做不到，就老老实实提升自己，别有事没事在那意淫一番。 其实，归根结底，缺乏动力还是来源认知不足，就好比认知突围中说的，根源都在于认知能力受限。还有一个原因，没有压力，活的太轻松，说大了，总而言之一句话，可以玩，没问题，但请分清主次。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[实用jq代码片段【一】]]></title>
    <url>%2F2016%2F05%2F01%2Fi034%2F</url>
    <content type="text"><![CDATA[链式操作1234567$(document).ready(function()&#123; $(&quot;button&quot;).click(function()&#123; $(&quot;#p1&quot;).slideUp(2000).slideDown(2000).css(&quot;color&quot;,&quot;red&quot;); $(&quot;#div-log&quot;).html(&quot;&lt;p&gt;&quot;+&quot;实现链式（Chaining）操作&quot;+&quot;&lt;/p&gt;&quot;); //类似于+= &#125;);&#125;); 区分客户区，页面区，屏幕区 三者的X轴没什么说的，都一样，主要区别在于Y轴上，客户区，屏幕区的最大值固定，不会随着页面的滚动改变。页面区会随着滚动条的改变而变化。 123456789101112131415161718192021222324252627282930313233//客户区$(document).ready(function ()&#123; $(document).mousemove(function(e)&#123; getclient(e); &#125;);&#125;);function getclient(e)&#123; x=e.clientX; //当前可视窗口的距离 y=e.clientY; $(&apos;#x&apos;).html(&quot;X:&quot;+x+&quot;Y:&quot;+y);&#125;//屏幕区$(document).ready(function ()&#123; $(document).mousemove(function(e)&#123; getscreen(e); &#125;);&#125;);function getscreen(e)&#123; x=e.screenX; //屏幕的左上角为参考点距离屏幕边缘的距离 y=e.screenY; $(&apos;#x&apos;).html(&quot;X:&quot;+x+&quot;Y:&quot;+y);&#125;//页面区$(document).ready(function ()&#123; $(document).mousemove(function(e)&#123; getpage(e); &#125;);&#125;);function getpage(e)&#123; x=e.pageX; //相对于当前页面中的坐标（会随着滚动条的滚动而变化） y=e.pageY; $(&apos;#x&apos;).html(&quot;X:&quot;+x+&quot;Y:&quot;+y);&#125; 左右自适应高度：1234567891011function $(id)&#123; return document.getElementById(id);&#125;(function autoheight()&#123; if($(&apos;left&apos;).offsetHeight&gt;=$(&apos;right&apos;).offsetHeight)&#123; $(&apos;right&apos;).style.height=$(&apos;left&apos;).offsetHeight+&quot;px&quot;; &#125;else&#123; $(&apos;left&apos;).style.height=$(&apos;right&apos;).offsetHeight+&quot;px&quot;; &#125;&#125;)()//需要注意的是必须自调用函数。 callback()函数 callback()函数在当前效果100%完成之后执行。在一个涉及动画的函数之后来执行语句，用callback()函数。 1234567$(document).ready(function ()&#123; $(&apos;button&apos;).click(function ()&#123; $(&apos;p&apos;).hide(1000,function ()&#123; alert(&quot;回调函数过程，激活一个提示框&quot;); &#125;); &#125;);&#125;); 在新窗口打开链接123456789$(document).ready(function ()&#123; $(&apos;.url&apos;).attr(&#123;target:&quot;_blank&quot;&#125;) $(&apos;a[rel=ext]&apos;).click(function ()&#123; $(this).attr(&apos;target&apos;,&apos;_blank&apos;) &#125;);&#125;);function openurl()&#123; window.open(&apos;http://www.microsoft.com&apos;);&#125; 页面淡入淡出1234567$(document).ready(function ()&#123; $(&apos;#fade&apos;).click(function ()&#123; $(&apos;#div-fade&apos;).fadeToggle(1000); $(&apos;#div-fade&apos;).fadeToggle(1000); $(&quot;#div-fade&quot;).fadeTo(1000,0.2); &#125;);&#125;); 折叠展开123456$(document).ready(function()&#123; $(&quot;.help h3&quot;).click(function()&#123; $(this).next(&quot;p&quot;).slideToggle(&quot;fast&quot;).siblings(&quot;p:visible&quot;).slideUp(&quot;fast&quot;);//siblings表示取得一个包含匹配的元素集合中每一个元素的所有唯一同辈元素的元素集合 &#125;);&#125;); 未完待续。。。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[收藏的面试题]]></title>
    <url>%2F2016%2F05%2F01%2F%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[以下是自己收藏网友的面试题，很实用；这只能帮你一般都会问什么，关键看自己平时的积累。临时抱佛脚没什么用，剩下的就看自己了。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>Job</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[setTimeout与setInterval的使用]]></title>
    <url>%2F2016%2F04%2F25%2Fi009%2F</url>
    <content type="text"><![CDATA[setTimeout和setInterval的语法相同。都有两个参数，一个是将要执行的代码字符串，还有一个是以毫秒为单位的时间间隔，当过了某个时间段之后就将执行那段代码。两者的区别在于，setInterval在执行完一次代码之后，经过了那个固定的时间间隔，它还会自动重复执行代码，而setTimeout只执行一次那段代码。但这并不意味着setTimeout只能用于on-off方式的动作上，可以通过创建一个函数循环重复调用setTimeout，以实现重复的操作： setTimeOut123456showTime();function showTime()&#123; var today = new Date(); alert(&quot;The time is: &quot; + today.toString()); setTimeout(&quot;showTime()&quot;, 5000);&#125; setInterval12345setInterval(&quot;showTime()&quot;, 5000);function showTime()&#123; var today = new Date(); alert(&quot;The time is: &quot; + today.toString());&#125; setTimeout方法不会每隔5秒钟就执行一次showTime函数，它是在每次调用setTimeout后过5秒钟再去执行showTime函数,而setInterval却可以每隔一定时间就重复执行一次那个函数。 用法： 需要每隔一个固定的时间间隔后就精确地执行某动作，那么最好使用setInterval，而如果不想由于连续调用产生互相干扰的问题，尤其是每次函数的调用需要繁重的计算以及很长的处理时间，那么最好使用setTimeout。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谎言的代价]]></title>
    <url>%2F2016%2F04%2F23%2F%E8%B0%8E%E8%A8%80%E7%9A%84%E4%BB%A3%E4%BB%B7%2F</url>
    <content type="text"><![CDATA[一个谎言需要更多谎言弥补，如果不是处于特定目的，谁会背上不诚信，人品有问题撒谎呢？有时候，我们不能光看撒谎本身，而应想想为什么撒谎，然后，再做判断也不迟。正如老话说的“在你不知道发生了什么的时候，请保持沉默”。没有人能够站在道德的制高点去批判他人，每个人都是独立的个体。就好比你现在穷的饭都吃不起的时候，地上有100块，你会捡起来交给警察叔叔吗？恐怕都是捡起来撒腿就跑吧！如果你年薪百万，恐怕也不会因为几百块与人闹得不可开交吧！关注点不同导致得出不一样的结论。1000个人中就有1000个哈姆雷特。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[$(document).ready()与window.onload()的区别]]></title>
    <url>%2F2016%2F04%2F20%2Fi005%2F</url>
    <content type="text"><![CDATA[$(document).ready()的表示在DOM加载完之后执行一个函数【这里DOM加载完不代表全部文件加载完，例如图片文件，虽然图的src的地址加载好了，但是图本身还没加载完】。 与window.onload的区别：1.执行时间： window.onload是在DOM加载完成 + DOM相关的文件下载完成 之后再执行函数。 $(document).ready()是在DOM加载完之后执行一个函数。 $(document).ready()要比window.onload先执行；有时候页面还没有完全加载完毕而用户已经在操作页面，在技术上很多情况下，只要DOM已完全加载好了，JS就可以运行去操作DOM了，没必要等到全部加载完成,所以用$(document).ready()来提前，但是当使用的JS依赖 CSS 属性值时，或者需要在元素被加载之后才能使用时（例如，取得图片的大小需要在图片被加载完后才能知道），就需要将这样的JS放到load事件中，以免因为贪图快而带来麻烦。 能够添加的数量： window.onload不能同时编写多个，因为我查看W3C的时候，window.onload是一种原生的DOM的事件，决定了在window上只能添加一个，后续的会覆盖掉前面的。 $(document).ready()可以同时编写多个，我查看jQuery中文档，他是这么介绍的.ready()方法只能被匹配当前文档的jQuery对象调用，也就是说他是jQuery的方法，本质是一个函数，就可以执行多次。 能否简写： $(document).ready()可以简写 window.onload 不能简写 $(document).ready()的简写: $(document).ready(handler) $(handler) $().ready(handler) //一般不推荐使用]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>ittech</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[家]]></title>
    <url>%2F2016%2F04%2F18%2F%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[故乡，之所以亲切，是因为那里有最亲的人，爱你的，你爱的，一家人坐在一起，彼此诉说着心中的牵挂。妈妈妈的唠叨在此时不再是唠叨，是关心。每次回到家，爸妈最关心的还是自己在外面过得怎样。而不会问你学的怎样。可能，在他们的心中，子女的健康超越一切。这2年，大姐，二姐都已成家，一家人见面可能也只有过年那几天了。从我放假到现在也有32天了，在这一个月的时间中，我能深深的感觉到家变得冷清了。虽然2个姐姐时常回来待几天，可这，跟之间相比，每年暑假，都是最热闹的。在之前，这些自己都根本不会想。也许正应了那句“失去时才知拥有”。 我无法想象，在未来若干年后，“空巢”会不会发生在我身上。于是，我暗暗发誓，绝对不让这种事在我头上发生。加油吧！少年，未来属于爱拼的你。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[巧记A标签4状态排序]]></title>
    <url>%2F2016%2F04%2F15%2Fi006%2F</url>
    <content type="text"><![CDATA[a:link,visited,hover,active.A标签4状态排序原则 HTML中A标签有4种状态，link,visited,hover,active，不过如果写CSS的时候排序错误就会导致状态失效或错乱。 A标签4种状态的排序规律符合一个原则，叫“爱恨原则”，由某国外友人提出，如下： LoVe/HAte 以上分别是爱与讨厌的单词，估计绝大部分人都记得。其中加亮的字母即是A标签4种状态的首字母。怎么样？如此来记，就一目了然了吧？ 感谢原作者的分享，虽然我不知道你是谁。 不过，我也有一个方法“LVHA”:LV：熟悉吗？那不是某个名牌吗。。。HA: 哈哈，记住了没。。。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《黑客与画家》]]></title>
    <url>%2F2016%2F04%2F15%2F%E9%BB%91%E5%AE%A2%E4%B8%8E%E7%94%BB%E5%AE%B6%2F</url>
    <content type="text"><![CDATA[什么是黑客做为名词，即可指很巧妙或很便捷的解决方法，也可以指比较笨拙、不那么优雅的解决办法。对于hacker，也有2种解释： 解释一，优秀程序员；解释二，侵入他人电脑的人。 技术布道者 技术布道师是最前线也是最重要的“翻译者”，他们能够把技术以易懂的方式解释给来自不同领域的人，以此获得他们对产品或技术的支持。这需要又懂技术又能挖掘出技术背后故事的人才，他们能够激发起人们对于一个产品的激情。 技术布道者供不应求的原因 专注在开发者技术和营销推广之间的重叠领域，其实这类角色的工作职责在科技公司已经有了，只不过现在以一个更加具体的名字出现。 欧洲初创公司越来愈多，所涉及的范围也越来越广，很多专注于SaaS（Software as a Service）和PaaS（Platform as a Service）的公司出现，平台化的流行间接增加了对技术布道者的需求。 技术布道者带有一定的光环，颇具诱惑力——人们一觉醒来突然发现这个职位的多样性和丰富的出差机会。 任何时候，我始终坚信，优质的东西终将都是稀缺的。 什么是黑客伦理 使用计算机以及所有有助于了解这个世界本质的事物都不应受到任何限制。任何事情都应该亲手尝试。 信息应该全部免费。 不信任权威，提倡去中心化。 判断一名黑客的水平应该看他的技术能力，而不是看他的学历、年龄或地位等其他标准。 你可以用计算机创造美和艺术。 计算机使生活更美好。 根据这六条“黑客伦理”，黑客价值观的核心原则可以概括成这样几点：分享、开放、民主、计算机的自由使用、进步。 如何创造财富 乔布斯曾经说过，创业的成败取决于最早加入公司的那十个人。我基本同意这个观点，虽然我觉得真正决定成败的其实只是前五人。小团队的优势不在于它本身的小，而在于你可以选择成员。我们不需要小村庄的那种“小”，而需要全明星第一阵容的那种“小”。 从经济学观点看，可以让人更快速工作的地方。你不再是慢慢地积累50年的普通工资，而是要尽快地将这笔钱赚到手。所以，政府禁止个人积累财富实际上就是命令人民减慢工作的速度。他们同意让你在50年里赚到300万美元，但是不同意让你在2年里赚到这些钱，即使前提是你拼命努力工作。这样的政府就像一家大公司的老板，你无法对他说，我打算十倍努力地工作，请你把我的薪水也增加十倍吧！更严重的是，他永远是你的老板，即使你自己创业也避不开他。 关注贫富分化 巴尔扎克说过：“每一笔巨大财富的背后，都隐藏着罪行。 为什么欧洲在历史上变得如此强大？是因为欧洲优越的地理位置，还是因为欧洲人天生就比较优秀，或者是宗教原因？答案（或者至少是近因）可能就是欧洲人接受了一个威力巨大的新观点：允许赚到大钱的人保住自己的财富。 金钱观这里有一个守恒定律：如果你想赚100万美元，就不得不忍受相当于100万美元的痛苦。 第一，我们从小被误导的对财富的看法；第二，历史上积累财富的方式大多名声不好；第三，担心收入差距拉大将对社会产生不利影响。就我所知，第一点是错的，第二点已经过时了，第三点通不过现实的检验。有没有可能，在现代社会中，收入差距拉大实际上是一种健康的信号？ 最后普及下常用术语 人工智能（AI，Artificial Intelligence）一个概括性术语，用来描述几种尝试让机器学会思考的技术。其中偏重数学的方法已经取得了一些进展（计算机视觉就是一个例子）。 带宽（bandwidth） 网络连接时传送数据的速度。 CGI脚本（Common Gateway Interface script，通用网关接口脚本） 当网络服务器需要进行某种运算（比如数据库搜索）而不是直接传输现有文件时所运行的一种程序。CGI脚本的主要缺点是，每次运行只能生成一个页面，无法像桌面软件那样将数据保存在内存中从而实现与用户的不间断对话。 CPU（中央处理器，Central Processing Unit） 计算机的一部分，如今通常是一块芯片，负责执行运算。这个概念正在变得模糊，因为处理器现在广泛用于各种各样的设备，比如显卡和硬盘。 冗余（cruft） 多余的不适用的信息（尤其指代码），也可用来指硬件。 数据结构（data structure）一种由多个部分组成的数据格式。比如，一对数据可以组成一个数据结构，表示图形上的一个点。 嵌入式语言（embedded language）在一种语言内部定义的另一种语言，常用于解决某些特殊的问题。比如，如果你定义了一系列操作图像的命令，你就可以把它们视为一种操作图像的语言，参见“自下而上编程法”（bottom-up programming）。 垃圾回收机制（garbage collection）程序自动判断哪些内存不再需要，并予以回收，而不是要求程序员在使用完毕后明确声明（这样的声明经常是错的）。 黑客（hacker）解释一，优秀程序员。解释二，侵入他人电脑的人。 HTML（超文本标记语言，HyperText Markup Language） 用来撰写网页的一套书写法。 HTTP（超文本传输协议，HyperText Transfer Protocol） 网络服务器与浏览器之间的通信协议。 帕金森定律（Parkinson’s Law）完成一项任务所需要的资源会不断扩展，直至把这种资源消耗光为止。 过早优化（premature optimization）还没有写完程序，你就开始考虑它的性能问题。这样的软件好比姑娘还没有成年却已经嫁人了。 正则表达式（regular expression）一种分解字符串的模式，就像筛子一样从字符串中取出想要的部分。 脚本语言（scripting language）一种编程语言，用来对某个程序进行定制。有时，开源编程语言（比如Perl和Python）也被称为脚本语言，但是这种叫法意义不大。 SSH（安全shell，Secure Shell） 可以安全连接远程计算机的一种程序。 SSL（安全套接字层，Secure Sockets Layer） 一种在网络上安全传输数据的协议。 URL（统一资源定位符，Uniform Resource Locator） 网页的地址。 更精确地说，是一个指向网络服务器的请求，目标通常是一个网页，但是也可能是要求某种操作（比如网络搜索）。 VC（风险投资商，Venture Capitalist） 为他人创业或再融资提供金钱的人，他们要求创业者用股份来交换投资。 带宽（bandwidth） 网络连接时传送数据的速度。]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[个人后花园的第一步]]></title>
    <url>%2F2016%2F04%2F10%2F%E4%B8%AA%E4%BA%BA%E5%90%8E%E8%8A%B1%E5%9B%AD%E7%9A%84%E7%AC%AC%E4%B8%80%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[在开始正题之前，我觉得我有必要说个事情，我推荐个JS前端开发联盟群。群号【76099500】，声明一下，这是个跳板群，无论是这个群还是其他高级群前辈们挺多的，技术氛围也是挺浓的，适合技术人。。。是的，今天我开通了后花园，灵感就是来自‘JS前端开发联盟群’,希望给自己一定的约束。主要分为2块，周结与月报。我会不断回顾过去，总结过去，并不断制定下一阶段的学习情况。]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[父元素padding后,子元素absolute定位偏差解决办法]]></title>
    <url>%2F2016%2F04%2F06%2Fi004%2F</url>
    <content type="text"><![CDATA[假设一div已经设置 position:relative及padding:30px，然后要在里面放置一position:absolute的元素，并设置它left:0;top:0——这种效果可用来实现左头像右内容的布局。 在Firefox等标准浏览器下，绝对定位的元素此时真的是左0上0，顶着父div的边，但IE下却是左30上30，只因为父div设置了padding为30。 这个问题很要命，那么解决办法呢？ 只要为父div加上zoom:1，触发其hasLayout，即可在IE下实现和标准浏览器下一样的样式了。此解决方案适合绝大部分情况。 每发现IE一个无厘头BUG，都会让我对IE的恨加深一层。兼容问题，’您’辛苦了…]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端开发网站收录]]></title>
    <url>%2F2016%2F03%2F28%2Fi003%2F</url>
    <content type="text"><![CDATA[程序员垂直导航 程序员垂直导航 前端导航 面试 MD文件简历在线编辑器 前端社区 大前端 技匠社 百度前端技术社区 720云 前端收录 Glup中文网 手册网 Node爱好者 JQuery在线手册 w3cplus 前端学习网站推荐 极客标签 码农周刊 前端周刊 慕课网 div.io Hacker News Hacker News InfoQ w3cplus Stack Overflow w3school mozilla 优秀博客 前端英雄榜 前端名录 开发工具 网站载入速度测试 多种MD文件编辑器 MD文件编辑器 开发教程SVG教程]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>Web前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[书]]></title>
    <url>%2F2016%2F03%2F28%2F%E6%88%91%E4%B8%8E%E4%B9%A6%E7%9A%84%E6%95%85%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[开卷有益，书，带给我们知识的时候，也逐渐强壮了我们的心智。在我的书单中，不仅限于专业书，更多的是我个人喜欢的方面。哈哈，暴露了我的读书观，不过也罢，实话实说嘛。专业书开拓了我的专业广度与深度。比如《JavaScriptDOM编程艺术》这本，我知道了“insertAfter”,以前只知道它不向insertBefore那样，本身就存在的直接用就可以，这是就需要自己创建。在我的书单中，《富爸爸，穷爸爸》，《富同学，穷同学》，《赚未来十年的钱》，《优秀的人都敢对自己下狠手》,《基金投资》等启蒙了我的金钱观，价值观。总之，每本书，在你读完后，总会有几个地方不时出现在你的脑海中，引起你的思考。每本书之间思维的碰撞，终将深刻地影响这你的行为。 弗朗西斯·培根在《论读书》里说道： 有些书只需浅尝，有些书可以狼吞，有些书要细嚼慢咽，慢慢消化。也就是说，有的书只需选读，有的书只需浏览，有的书却必须全部精读。有的书不必去读原文，读读它们的节本就够了，但这仅限于内容不大重要的二流书籍：否则，删节过的往往就像蒸馏水一样，淡而无味。 以下是我个人推崇的： 《软技能，代码之外的生存指南》 《驱动力》 《优秀的人都敢对自己下狠手》 《富爸爸，穷爸爸》 《富同学，穷同学》 《赚未来十年的钱》 《自控力》 《把时间当做朋友》]]></content>
      <categories>
        <category>books</category>
      </categories>
      <tags>
        <tag>books</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客带给我的]]></title>
    <url>%2F2016%2F03%2F25%2F%E5%8D%9A%E5%AE%A2%E5%B8%A6%E7%BB%99%E6%88%91%E7%9A%84%2F</url>
    <content type="text"><![CDATA[博客，在经历了3天后博客终于搭建好了，现在万事俱备，只欠东风，博客，重在内容，不论以怎样形式，内容永远都是第一位的，之前想自己开发个个人网站，但最后还是不了了之，最主要的还是因为不方便操作，也不能随时随地畅谈。尝试过博文，简书，现在使用hexo，之后很有可能在github上的issues上，总之一切都是为了更好更方便的记录。现在我又想做个时光轴，以周或月为基数，记录自己的成长。我能感觉到记录带给我的成就感。犹记得看儿时照片，很开心，此时的心情无法用言语表达，依次类推，若干年后，看看现在的自己的选择，会会心一笑，这，就够了。今天，看到这样一句话 浮躁来源于内心的不安定，唯有静，而这，也是自己的一个初衷吧！]]></content>
      <categories>
        <category>back-yard</category>
      </categories>
      <tags>
        <tag>back-yard</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中中elm.style.xxx无法获取到CSS值]]></title>
    <url>%2F2016%2F03%2F20%2Fi002%2F</url>
    <content type="text"><![CDATA[javascript中elm.style.xxx无法获取到CSS值 示例代码如下： 12345.d1&#123;color:#f00;&#125;&lt;div id=”d1″ class=”d1″&gt;获取css值&lt;/div&gt;//此时使用JS的style获取他的color属性：var d1=document.getElementById(‘d1’);alert(d1.style.color); 奇怪的是，弹出一个空值，没有任何内容，也不报错。但如果用d1.style.color=”#00f”来设置d1的CSS却正确执行。 百思不得其解，上网一搜。 解释说elm.style只能获取到elm标签上类似style=””定义的CSS属性，我靠，那怎么得到通过class来声明的属性呢？ IE中用elm.currentStyle.color的语句来获得——这种方法还能接受。 但自诩标准的W3C获取方法如下： 12var d1 =document.getElementById(‘d1’);alert(window.getComputedStyle(d1,null).color); 要用到一个很生的JS语句：getComputedStyle。这不重要，重要的是这个语句的使用方法，居然要通过window对象调用！参数居然是两个而且第二个就算是空的也不能省略！这条语句对比起elm.style甚至elm.currentStyle都要繁琐的多，而且打乱了一般的JS编程习惯。虽然通过getComputedStyle真的能取到对应的CSS值，但这个方法不得不说很是无语!]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用text-indent实现图片Logo代替文字Logo]]></title>
    <url>%2F2016%2F03%2F13%2Fi001%2F</url>
    <content type="text"><![CDATA[一个网站，logo是肯定少不了的。最常用的就是图片logo或直接打几个字当作logo。 毫无疑问，图片logo远比文字好看，图片可以色彩缤纷变幻无穷，而文字变来变去都那样。但直接用文字logo的还是有很多，因为纯文字更利于搜索引擎识别，图片就不行了。 有没有两全其美的方法呢？有的人使用这种： 1&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;/logo.png&quot; title=&quot;图片说明&quot; alt=&quot;图片说明&quot;/&gt;&lt;/a&gt; 搜索引擎无法看到图片，但可以看到图片说明，这样也就相当于文字了————这也是SEO中强调要给图片加上alt的原因。 但其实这种方法并不完美，很多人都不喜欢加alt标记，而且这样对搜索引擎到底有没有妨害也难说清。下面介绍一种国际国内通用的方法. html代码，非常简单： 123456&lt;a href=&quot;#&quot; class=&quot;logo&quot;&gt;这是logo&lt;/a&gt;.logo&#123;background:url(images/logo.png) no-repeat;/*把你的logo图片设成背景图*/height:60px; width:150px; /*设置宽高*/text-indent:-9999px; /*设置文字缩进*/&#125; CSS代码最关键的一步就是最后的text-indent，text-indent的意思是文字缩进，它的单位一般是正数，用来将段落前空格。但这里把它的单位设为了负值，-9999px，于是原本在A标签里面的文字就被缩到不知道哪儿去了。 这样一来，用户看到的就是图片logo（背景图），而搜索引擎看到的却是正宗的文字，一举两得。 举一反三，这种方法可以用来制作图片导航栏和标题栏，但我不推荐哈，因为这两者需要做的图片太多了，麻烦，而且修改起来更麻烦。]]></content>
      <categories>
        <category>ittech</category>
      </categories>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
</search>
